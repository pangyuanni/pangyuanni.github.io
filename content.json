{"meta":{"title":"风晓博客","subtitle":"只有飘零的风，知道你所欲所求","description":"一个喜欢瞎玩的博主","author":"风晓","url":"http://www.windknows.com"},"pages":[{"title":"404 Not Found","date":"2020-01-23T08:04:56.888Z","updated":"2020-01-23T02:49:33.658Z","comments":true,"path":"404.html","permalink":"http://www.windknows.com/404.html","excerpt":"","text":"404 Not Found 很抱歉，您访问的页面不存在可能是输入地址有误或该地址已被删除"},{"title":"我的朋友们","date":"2020-01-27T05:03:26.134Z","updated":"2020-01-27T05:03:26.128Z","comments":true,"path":"friends/index.html","permalink":"http://www.windknows.com/friends/index.html","excerpt":"","text":"各位大佬想交换友链的话可以在下方留言，必须要有名称、头像链接、和至少一个标签哦～ 名称： 风晓博客头像： http://i2.tiimg.com/708378/9da6ad9df503cebc.jpg网址： https://www.windknows.com标签： iOS"},{"title":"关于","date":"2020-01-27T05:00:25.774Z","updated":"2020-01-27T05:00:25.764Z","comments":true,"path":"about/index.html","permalink":"http://www.windknows.com/about/index.html","excerpt":"","text":"&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 这是第一次搭建的博客，请随意留言，但是我不会回复 One More Thing懒加载占位图如果喜欢请拿去：图片链接 欢迎灌水"},{"title":"","date":"2020-01-23T08:04:56.892Z","updated":"2020-01-23T02:49:33.689Z","comments":true,"path":"projects/index.html","permalink":"http://www.windknows.com/projects/index.html","excerpt":"","text":""},{"title":"所有分类","date":"2020-01-23T08:04:56.891Z","updated":"2020-01-23T02:49:33.686Z","comments":true,"path":"blog/categories/index.html","permalink":"http://www.windknows.com/blog/categories/index.html","excerpt":"","text":""},{"title":"所有标签","date":"2020-01-23T08:04:56.891Z","updated":"2020-01-23T02:49:33.687Z","comments":true,"path":"blog/tags/index.html","permalink":"http://www.windknows.com/blog/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"在家学习java第二天","slug":"java-1","date":"2020-02-07T01:25:25.000Z","updated":"2020-02-07T04:21:32.149Z","comments":true,"path":"java-1/","link":"","permalink":"http://www.windknows.com/java-1/","excerpt":"","text":"前言在家无聊学习java第二天 内容常量 字符串常量 整数常量 浮点数常量 字符常量 布尔常量 空常量：null 1234567891011121314151617181920212223242526272829public class TwodayDemo1&#123; public static void main(String[] args)&#123; //字符串常量 System.out.println(\"ABC\"); System.out.println(\"\"); System.out.println(\"XYZ\"); //整数常量 System.out.println(30); System.out.println(-30); //浮点数常量（小数） System.out.println(3.14); System.out.println(-2.5); //字符常量 System.out.println('A'); System.out.println('6'); //System.out.println(''); 两个单引号中间必须有且仅有一个字符，没有就会报错 //System.out.println('AB') 有两个字符也不行 //布尔常量 System.out.println(true); System.out.println(false); //空常量，不能直接用来打印输出 // System.out.println(null); 会报错 &#125;&#125; 数据类型java的数据类型分为两大类： 基本数据类型 引用数据类型 基本数据类型四类八种基本数据类型 数据类型 关键字 内存占用 取值范围 字节型 byte 1个字节 -128~127 短整型 short 2个字节 -32768~32767 整形 int（默认） 4个字节 -2^31^~2^31^-1 长整型 long 8个字节 -2^63^~2^63^-1 单精度浮点数 float 4个字节 1.4013E-45~3.4028E+38 双精度浮点数 double（默认） 8个字节 4.9E-324~1.7977E+308 字符型 char 2个字节 0-65535 布尔类型 boolean 1个字节 true false 【SP】 java中的默认类型，整形是int，浮点型是double 字符串不是基本类型而是引用类型 浮点型可能只是一个近似值，并非精确的值 数据范围与字节数并不一定相关，如float数据范围比long更加广泛，单float是4字节而long是8字节 如果使用float需加后缀F，若使用long后缀需加L，推荐使用大写字母后缀 1234System.out.println(100);//是int型System.out.println(100L);//是long型System.out.println(100.2);//是double型System.out.println(100F);//是float型 变量的定义变量定义有以下两种方式 创建一个变量并且使用的格式 数据类型 变量名称 //创建一个变量 变量名称 = 数据值 //赋值 一步到位 数据类型 变量名称 = 数据值；//在创建变量同时，立刻放入指定的数据值 12345678910111213141516171819202122232425262728293031323334353637383940public class Day02&#123; public static void main(String[] args)&#123; //方式一 int num1; num1 =10; System.out.println(num1); //方式二 int num2 = 25; System.out.println(num2); System.out.println(\"--------------\"); byte num3 = 30; //注意右侧数值不能超过左侧数据类型的数据范围 System.out.println(num3); //byte num4 = 400;// 右侧超出了byte的取值范围，错误！！ short num5 = 50; System.out.println(num5); long num6 = 3000000L; System.out.println(num6); float num7 = 2.5F; System.out.println(num7); double num8 = 1.2; System.out.println(num8); char zifu1 = 'A'; System.out.println(zifu1); zifu1 = '中'; System.out.println(zifu1); boolean var1 = true; System.out.println(var1); var1 = false; System.out.println(var1); &#125;&#125; TIPS 变量之间不能重复 对于float和long后缀不能丢掉 如果用type和long注意取值范围 没有进行赋值的变量，不能直接使用，一定要复制之后才能进行使用（如打印输出操作） 变量不要超出变量的定义域 数据类型转换 自动转换 一个int类型变量和一个byte类型变量进行加法运算，结果是什么类型？ 12int i =1;byte b = 2; 运算结果，变量的类型将是int类型，这就是出现了数据类型的自动类型转换现象 自动转换(隐式)：将取值范围小的类型自动提升为取值范围大的类型 12345678public static void main(String[] args) &#123; int i =1; byte =2; //byte x = b+i //报错 //int 类型和byte；类型运算，结果是int int j = b+i; System.out.println(j);&#125; 规则：数据范围从小到大 123long num1 = 100;//左边是long，右边是int，从int--long是从小到大，自当发生数据类型转换double num2 = 2.5F;float num3 =30L; 强制类型转换 代码需要进行特殊的格式处理，不能自动完成 范围小的类型 范围小的变量名 = （范围小的类型）原本范围大的数据 1234int num = (int) 100L;//左边是int类型，右边是long类型，不一样//long --&gt; int ，不是从小到大，不能发生自动化类型转换//范围小的类型 范围小的变量名 = （范围小的类型）原本范围大的数据 Tips 强制类型转换一般不使用，因为有可能发生精度损失，数据溢出 12int num =(int) 6000000000L;输出num为17亿数据溢出 byte/short/char三种类型都可以发生数学运算 byte/short/char三种类型在运算的时候，都会被首先提升为int类型然后再计算 boolean 不能发生数据类型转换 运算符一元运算符 取反 ！ 自增 ++ 自减 – 二元运算符 + - * / = 三元运算符数据类型 变量名称 = 条件判断 ？ 表达式A：表达式B; 123int a;int b;int max = a &gt; b ? a : b; Tips 必须同时保证表达式A和表达式B都符合左侧数据类型的要求 三元运算符的结果必须被使用 123int result = 3 &gt; 4 ? 2.5 : 10 ; //错误 数据类型不一致System.out.println(a &gt; b ? a : b);//正确写法a &gt; b ? a : b //错误写法，没有进行使用","categories":[{"name":"java","slug":"java","permalink":"http://www.windknows.com/blog/categories/java/"},{"name":"教程","slug":"java/教程","permalink":"http://www.windknows.com/blog/categories/java/教程/"}],"tags":[{"name":"学习，java","slug":"学习，java","permalink":"http://www.windknows.com/blog/tags/学习，java/"}]},{"title":"在家java学习第一天","slug":"java","date":"2020-02-06T08:41:42.000Z","updated":"2020-02-07T04:21:55.437Z","comments":true,"path":"java/","link":"","permalink":"http://www.windknows.com/java/","excerpt":"","text":"前言​ 下学期要学习java，闲来无事，开始了自学之旅，用于记录学习java的全过程，当是学习笔记吧 什么是java，以及java发展史什么是java语言Java语言是美国Sun公司（Stanford University Network）斯坦福大学网络公司，在1995年推出的高级编程语言，所谓编程语言，是计算机的语言，人门可以使用编程语言对计算机下达命令，让计算机完成人门需要的功能 Java语言之父James Gosling就是这家公司非常nb的程序员，关于java之父的详细了解，可以看看以下这篇文章 ​ java之父及java诞生 ​ java语言之父 James Gosling Java发展史 1995年Sun公司发布java1.0版本 1997年发布java1.1版本 1998年发布java1.2版本 2000年发布java1.3版本 2002年发布java1.4版本 2004年发布java5版本（因为和1.4变化太大，更新力度太大，所以用大版版本号来表示） 2006年发布java6版本 2009年Oracle甲骨文公司收购Sun公司，并于2011年发布java7版本 2014年发布java8版本 2017年9月发布java9版本 2018年3月发布java10版本 Java的应用Java语言经过多年的发展已经形成了一个较为健全的语言生态，在Web开发、大数据开发、Android开发等领域均有广泛的应用，而且凭借稳定的性能表现和较强的扩展性，目前Java语言依然是大型互联网平台较为常见的解决方案，采用Java语言进行大型后端系统的开发会在很大程度上降低开发风险。JAVA的一次编译，到处运行，你知道多少？](https://blog.csdn.net/wangyongxia921/article/details/28117155) Java环境的搭建 JVM (java Virtual Machine):java虚拟机，简称JVM，是运行所有java程序的假想计算机，是java程序的运行环境，是java最具吸引力的特性之一，我们编写的JVM之上 跨平台：任何软件的运行，都必须要运行在操作系统之上，而我们用Java编写的软件可以运行在任何的操作系统上，这个特性称为java语言的跨平台特性，该特性是由JVM实现的，我们编写的程序运行在JVM上，而JVM运行在操作系统上（这就是著名的‘一次编写，到处运行’）可以看看这篇文章JAVA的一次编译，到处运行，你知道多少？ ​ JRE和JDK JRE (java Runtime Environment) :是java程序的运行时环境，包含JVM和运行时所需要的核心类库 JDK (java Development Kit):是java程序开发工具包，包含JRE和开发人员使用的工具 我们想要运行一个已有的java程序，那么只需要安装JRE即可 我们想要开发一个全新的java程序，那么必须安装JDK JDK，JRE，JVM关系图 下载安装JDK 可以选择不同的版本号,(我无论什么都喜欢下载最新的我下载的是最新的) 选择相应的java版本，点进去 选择相应系统的jdk点击下载 下载成功之后点击安装 注意这个路径问题 添加环境变量将我们的jdk安装的bin目录添加到环境变量path里 然后打开cmd测试 这样就说明，jdk环境变量配好了 Hello World新建一个文本文档，命名为HelloWorld.java 12345public class HelloWorld&#123; public static main(String[] args)&#123; System.out.println(\"Hello,World\"); &#125;&#125; 执行javac 编译HelloWorld.java执行后什么都不出现，同目录下会出现.class的字节码文件 然后java HelloWorld 就能成功执行该文件 注意用的是java HelloWorld，java后面一个空格，加不加后缀的文件名 今天就学了这么多，明天再学变量什么的，","categories":[{"name":"java","slug":"java","permalink":"http://www.windknows.com/blog/categories/java/"},{"name":"教程","slug":"java/教程","permalink":"http://www.windknows.com/blog/categories/java/教程/"}],"tags":[{"name":"学习，java","slug":"学习，java","permalink":"http://www.windknows.com/blog/tags/学习，java/"}]},{"title":"文泉课堂爬虫源码","slug":"wenquanketang-spider","date":"2020-02-05T02:21:59.000Z","updated":"2020-02-05T10:11:56.477Z","comments":true,"path":"wenquanketang-spider/","link":"","permalink":"http://www.windknows.com/wenquanketang-spider/","excerpt":"","text":"前言今天打开发现文泉课堂需要登陆才能进行访问，一登陆，发现，昨天的502，明显好多了今天附上所有源码，供大家学习和参考 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160#!/usr/bin/env python# -*- coding:utf-8 -*-# Author:风晓import requestsimport timefrom pathlib import Pathimport osimport jwtimport jsonfrom tqdm import trangedata =&#123;&#125;headers =&#123; &apos;user-agent&apos;: &apos;Mozilla/5.0 (Windows NT 10.0; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/69.0.3497.100 Safari/537.36&apos;, &#125;JWT_SECRET = &apos;g0NnWdSE8qEjdMD8a1aq12qEYphwErKctvfd3IktWHWiOBpVsgkecur38aBRPn2w&apos;# SESS = httpx.Client()URL = &apos;https://lib-nuanxin.wqxuetang.com&apos;# SESS.get(URL)&apos;&apos;&apos; jwt key for bookid &apos;&apos;&apos;# url = &quot;https://lib-nuanxin.wqxuetang.com/v1/read/k?bid=%s&quot; % bookiddef gen_jwt_key(bookid,cooike): url = f&apos;&#123;URL&#125;/v1/read/k?bid=&#123;bookid&#125;&apos; print(url) # r = self.session.get(url, timeout=5) # r = SESS.get(url, timeout=5) # j = json.loads(r.text) head = &#123; &apos;Accept&apos;: &apos;text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,*/*;q=0.8&apos;, &apos;Accept-Encoding&apos;: &apos;gzip, deflate, sdch&apos;, &apos;Accept-Language&apos;: &apos;zh-CN,zh;q=0.8&apos;, &apos;Connection&apos;: &apos;keep-alive&apos;, &apos;Cookie&apos;: cooike, &apos;Host&apos;: &apos;lib-nuanxin.wqxuetang.com&apos;, &apos;Upgrade-Insecure-Requests&apos;: &apos;1&apos;, &apos;User-Agent&apos;: &apos;Mozilla/5.0 (Windows NT 10.0; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/49.0.2623.112 Safari/537.36&apos;, &#125; try: resp = requests.get(url,headers = head) resp.raise_for_status() except Exception as exc: print(exc) try: jdata = resp.json() except Exception as exc: jdata = &#123;&#125; res = jdata.get(&apos;data&apos;) if res is None: raise Exception(&apos;returned None, something is not right...&apos;) return resdef gen_jwt_token(bookid, page,cooike): &apos;&apos;&apos; gen jwt token &apos;&apos;&apos; cur_time = time.time() jwtkey = gen_jwt_key(bookid,cooike) print(jwtkey) jwttoken = jwt.encode( &#123; &quot;p&quot;: page, &quot;t&quot;: int(cur_time) * 1000, &quot;b&quot;: str(bookid), &quot;w&quot;: 1000, &quot;k&quot;: json.dumps(jwtkey), &quot;iat&quot;: int(cur_time), &#125;, JWT_SECRET, algorithm=&apos;HS256&apos;, ).decode(&apos;ascii&apos;) print(jwttoken) return jwttokendef bookinfo(bookid,cooike): &apos;&apos;&apos; bookinfo &apos;&apos;&apos; # url = f&quot;https://lib-nuanxin.wqxuetang.com/v1/read/initread?bid=&#123;self.bookid&#125;&quot; # noqa url = f&apos;&#123;URL&#125;/v1/read/initread?bid=&#123;bookid&#125;&apos; # r = self.session.get(url) head = &#123; &apos;Accept&apos;: &apos;text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,*/*;q=0.8&apos;, &apos;Accept-Encoding&apos;: &apos;gzip, deflate, sdch&apos;, &apos;Accept-Language&apos;: &apos;zh-CN,zh;q=0.8&apos;, &apos;Connection&apos;: &apos;keep-alive&apos;, &apos;Cookie&apos;: cooike, &apos;Host&apos;: &apos;lib-nuanxin.wqxuetang.com&apos;, &apos;Upgrade-Insecure-Requests&apos;: &apos;1&apos;, &apos;User-Agent&apos;: &apos;Mozilla/5.0 (Windows NT 10.0; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/49.0.2623.112 Safari/537.36&apos;, &#125; try: bookid = int(bookid) except Exception as exc: print(exc) raise if bookid &lt; 1: # logger.warning(f&apos; bookid &#123;bookid&#125; &lt; 1, setting bookid to 1&apos;) # bookid = 1 raise Exception(&apos; bookid must be bigger than zero&apos;) try: print(url) resp = requests.get(url,headers=head) resp.raise_for_status() except Exception as exc: print(exc) try: jdata = resp.json() except Exception as exc: print(exc) jdata = &#123;&#125; data = jdata.get(&apos;data&apos;) print(data) if data is None: raise Exception( &apos;returned None, something is not right...可能无此书号，也有可能是网络有问题或IP被限制……&apos; # noqa ) bookinfo.jdata = jdata # print(data.get(&apos;canreadpages&apos;)) print(data.get(&apos;name&apos;), data.get(&apos;canreadpages&apos;)) return data.get(&apos;name&apos;), data.get(&apos;canreadpages&apos;)def fetch_png(bookid, page=1): &apos;&apos;&apos; download booid page img &apos;&apos;&apos; token = gen_jwt_token(bookid, page,cooike) print(token) url = f&apos;&#123;URL&#125;/page/img/&#123;bookid&#125;/&#123;page&#125;?k=&#123;token&#125;&apos; print(url) headers = &#123; &apos;accept&apos;: &apos;image / webp, image / *, * / *;q = 0.8&apos;, &apos;referer&apos;: f&apos;&#123;URL&#125;/read/pdf/&#123;bookid&#125;&apos;, &apos;user-agent&apos;: &apos;Mozilla/5.0 (Windows NT 10.0; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/69.0.3497.100 Safari/537.36&apos;, # noqa &#125; req = requests.get(url,headers=headers) res = req.content if not os.path.exists(str(bookid)): os.mkdir(str(bookid)) with open(str(bookid)+&apos;/&apos;+str(page+1000)+&apos;.jpg&apos;,&apos;wb&apos;)as f: f.write(res) return resif __name__ == &apos;__main__&apos;: &apos;&apos;&apos;使用时更改bookid和将你的cooike更换成你的&apos;&apos;&apos; &apos;&apos;&apos;https://lib-nuanxin.wqxuetang.com/v1/read/k?bid=3187886&apos;&apos;&apos; &apos;&apos;&apos;cooike用上面的url然后进去f12调试复制里面的cooike&apos;&apos;&apos; bookid =3187886 cooike = &apos;_gid=377254409517; _gidv=6699d59c633414a0287f63aa61c56d4e; PHPSESSID=ngeq25ktm1cp2ipd54kabr2eii; Hm_lvt_a84b27ffd87daa3273555205ef60df89=1580866455,1580876574,1580883745,1580883761; Hm_lpvt_a84b27ffd87daa3273555205ef60df89=1580883767; acw_tc=3ccdc15315808917923211688e5e6c7e01cc28622fbf0190a83bc6ce183541&apos; try: page = bookinfo(bookid,cooike)[1] print(page) if not os.path.exists(str(bookid)): os.mkdir(str(bookid)) for i in range(1,int(page)): if not os.path.exists(str(bookid)+&apos;/&apos;+str(i+1000)+&apos;.jpg&apos;): try: print(i) gen_jwt_token(bookid,i,cooike) fetch_png(bookid,i) time.sleep(6) except Exception as e: print(e) except Exception as e: print(e) 若大量遇到下面这种情况：空列表，则说明你的cooike可能过期及时更换就好 跑完一遍后打开你的图片保存路径，然后排序按大小，然后翻到最下面若和以下一样说明这几张没成功，删了 重新来一遍就好，重新跑，不会覆盖之前的，只会抓取没有成功的： 最后推荐一个好用的小工具，图片合成pdf工具：pic2pdf 拥有这些，就可以成功的得到了自己的电子书。。今天就到这儿吧","categories":[{"name":"教程","slug":"教程","permalink":"http://www.windknows.com/blog/categories/教程/"}],"tags":[{"name":"python","slug":"python","permalink":"http://www.windknows.com/blog/tags/python/"},{"name":"爬虫","slug":"爬虫","permalink":"http://www.windknows.com/blog/tags/爬虫/"}]},{"title":"文泉课堂知识库图书爬虫","slug":"spider-wenquanketang","date":"2020-02-04T05:38:17.000Z","updated":"2020-02-04T09:22:19.439Z","comments":true,"path":"spider-wenquanketang/","link":"","permalink":"http://www.windknows.com/spider-wenquanketang/","excerpt":"","text":"前言昨天导员老师发了个通知，说在疫情期间，清华大学的文泉课堂资源免费开放，那何不用爬虫技术，将所有的的电子书下载下来，于是就有了这篇文章 思路首先确定一下爬取的思路，浏览了一下发现并没有直接下载的链接，只能免费的阅读里面的书，打开阅读界面，书是以图片的形式呈现的，于是我们的爬虫思路是按顺序爬取所有的图片，最后合成一个pdf文件，这样我们就成功的获取到了这本书的pdf版 过程我们打开浏览器，随便打开一本书，然后打开调试，发现网页源码并不能直接获得，是通过动态加载的，所以只能考虑图片地址的规律 我们会发现，图片的url是页数，后面是一串字符串，这时经百度发现这是jwt 可以理解成是web验证身份的一种方式吧，我也是第一次接触，在网上看了很多相关的文章，在这里推荐几篇 利用JWT生成Token的原理及公钥和私钥加密和解密的原则 JSON Web Token - 在Web应用间安全地传递信息 10分钟了解JSON Web令牌（JWT） Jwt简介 简单地说JWT 的原理是，服务器认证以后，生成一个 JSON 对象，发回给用户，就像下面这样。 1eyJhbGciOiJIUzI1NiJ9.eyJpc3MiOiJuaW5naGFvLm5ldCIsImV4cCI6IjE0Mzg5NTU0NDUiLCJuYW1lIjoid2FuZ2hhbyIsImFkbWluIjp0cnVlfQ.SwyHTEx_RQppr97g4J5lKXtabJecpejuef8AqKYMAJc jwt由三部分构成分别如下 123Header（头部）Payload（负载）Signature（签名） 我百度了一下有个jwt的在线解密的网站，进去后随便复制一个图片的token如图： 里面的数据： alg属性表示签名的算法（algorithm），默认是 HMAC SHA256（写成HS256）；typ属性表示这个令牌（token）的类型（type），JWT 令牌统一写为JWT。 中间的dict是Payload，可以理解成我们要给服务器的数据，其中p代表页数，t是时间戳，b是书的id就是bid，k值我看了半天没看懂，后来在网页中我发现了个请求如下图： ​ 刚好和上面的k值里的u，i，t，b，n对上，所以我就肯定没错了，是 这个 了，然后所有的东西确定了之后，我们就开始构建吧,然后在Headers里找到相关信息，并进行获取就行 最下面的是Signature 部分是对前两部分的签名，防止数据篡改。 算出签名以后，把 Header、Payload、Signature 三个部分拼成一个字符串，每个部分之间用”点”（.）分隔，就可以返回给用户。 代码如下图示 123456789101112131415161718def gen_jwt_token(bookid, page): ''' get jwt token ''' cur_time = time.time() //时间戳 jwtkey = gen_jwt_key(bookid) //token里的k值 jwttoken = jwt.encode( &#123; \"p\": page, \"t\": int(cur_time) * 1000, \"b\": str(bookid), \"w\": 1000, # \"k\": json.dumps(self.jwtkey), \"k\": json.dumps(jwtkey), \"iat\": int(cur_time), &#125;, //进行编码 JWT_SECRET, algorithm='HS256', ).decode('ascii') return jwttoken k值获取代码 12345678910111213141516171819def gen_jwt_key(bookid): URL ='https://lib-nuanxin.wqxuetang.com' url = f'&#123;URL&#125;/v1/read/k?bid=&#123;bookid&#125;' try: resp = requests.get(url,headers = headers) resp.raise_for_status() except Exception as exc: print(exc) try: jdata = resp.json() except Exception as exc: jdata = &#123;&#125; res = jdata.get('data') if res is None: raise Exception('returned None, something is not right...') return res 有了这些我们就可以来轻松的获取图片了 我们可以发现图片的url规律是 12URL = 'https://lib-nuanxin.wqxuetang.com'f'&#123;URL&#125;/page/img/&#123;bookid&#125;/&#123;page&#125;?k=&#123;token&#125;' 然后就可以来获取图片了 1234567891011121314151617def fetch_png(bookid, page): ''' download book page img ''' token = gen_jwt_token(bookid, page) print(token) url = f'&#123;URL&#125;/page/img/&#123;bookid&#125;/&#123;page&#125;?k=&#123;token&#125;' print(url) headers = &#123; 'accept': 'image / webp, image / *, * / *;q = 0.8', 'referer': f'&#123;URL&#125;/read/pdf/&#123;bookid&#125;', 'user-agent': 'Mozilla/5.0 (Windows NT 10.0; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/69.0.3497.100 Safari/537.36', &#125; req = requests.get(url,headers=headers) res = req.content if not os.path.exists(str(bookid)): os.mkdir(str(bookid)) with open(str(bookid)+'/'+str(page)+'.jpg','wb')as f: f.write(res) 当我们获取到书的所有图片如图： 然后我们再用python将这些图片合成一个完整的pdf 具体代码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748# -*- coding:utf-8 -*-#!/usr/bin/env python# Author:windknewimport osfrom reportlab.lib.units import mm, inchfrom reportlab.lib.pagesizes import A4,A5, landscapefrom reportlab.pdfgen import canvas# 图片文件名称列表IMAGEFILES = []def convertpdf(pdfFile): '''多个图片合成一个pdf文件''' (w, h) = landscape(A5) # cv = canvas.Canvas(pdfFile,pagesize=landscape(A5)) for imagePath in IMAGEFILES: print(imagePath) cv.drawImage(imagePath, 0, 0, w, h) cv.showPage() cv.save()def getListImages(dirPath): '''读取指定文件夹下所有的JPEG图片，存入列表''' if dirPath is None or len(dirPath) == 0: raise ValueError('dirPath不能为空，该值为存放图片的具体路径文件夹！') if os.path.isfile(dirPath): raise ValueError('dirPath不能为具体文件，该值为存放图片的具体路径文件夹！') if os.path.isdir(dirPath): for imageName in os.listdir(dirPath): if imageName.endswith('.jpg') or imageName.endswith('.jpeg'): absPath =converPath(dirPath) + imageName IMAGEFILES.append(absPath)def converPath(dirPath): if dirPath is None or len(dirPath) == 0: raise ValueError('dirPath不能为空！') if os.path.isfile(dirPath): raise ValueError('dirPath不能为具体文件，该值为文件夹路径！') if not str(dirPath).endswith(\"\\\\\"): return dirPath + \"\\\\\" return dirPathif __name__ == '__main__': getListImages('C:/Users/lyh/Desktop/ershoushu/2175744/') pdfFile = converPath('C:/Users/lyh/Desktop/ershoushu/2175744/')+'2175744'+ \".pdf\" convertpdf(pdfFile) 结语总结 这样我们就成功的获取到了一本想要的pdf，但是文泉课堂不知什么原因有时候就会502，这样的话我们就需要多爬几次，直到把整本书的img都抓到，这次分享就到这儿了","categories":[{"name":"python","slug":"python","permalink":"http://www.windknows.com/blog/categories/python/"}],"tags":[{"name":"爬虫，python","slug":"爬虫，python","permalink":"http://www.windknows.com/blog/tags/爬虫，python/"}]},{"title":"使用hexo搭建博客（四）","slug":"hexo-3","date":"2020-02-04T04:18:25.000Z","updated":"2020-02-03T07:36:26.239Z","comments":true,"path":"hexo-3/","link":"","permalink":"http://www.windknows.com/hexo-3/","excerpt":"","text":"前言承接上篇博客，上篇博客中我们在Github上部署成功，但Github上的访问速度在国内较慢，而且免费提供的资源有限，不适于长时期的博客运作，所以在此篇文章中，来说一下，我部署在云服务器的过程以及遇到的问题 首先我们了解一下，hexo利用git更新的流程，部署在Github上和部署在云服务器上没有特别大的本质区别 整个流程就是本地将markdown文件渲染成静态文件，然后Git推送到服务器的r代码仓库，让服务器通过钩子（hook）同步网站根目录，再利用nginx托管这些静态资源，就可以实现访问 环境本地环境Windows10,在本地已经装好了Git，nodejs，hexo，并且在本地已经成功的能调试出来hexo 服务器环境华为的ECS（centos7） 已装好了git，nodejs，以及编译好了nginx（编译这玩意儿有些慢，我编译的时候大概花了将近30分钟） 本地机器配置配置密钥在终端使用git bash生成公匙，命令如下： 1ssh-keygen -t rsa 然后一路回车， 就会在如图示的文件路径下生成一个密钥文件id_rsa.pub 这个密钥文件我们后面会用到，这个密钥相当于我们访问服务器的钥匙 云服务器配置Git，nodejs，Nginx等安装具体安装过程可自行百度 创建git新用户以及进行配置创建git新用户1234adduser git #加入git用户passwd git #配置你的密码chmod 740 /etc/sudoers/ #修改git的sudo使用权限为只读vim /etc/sudoers #编辑sudoers 打开sudoers，找到以下内容 12## Allow root to run any commands anywhereroot ALL=(ALL) ALL 在他的下面加入以下内容 1git ALL=(ALL) ALL 然后wq保存，并且将权限修改回来 1chmod 400 /etc/sudoers 将公钥配置到服务器上就是刚才我们生成的那个文件将该文件内容复制，在云服务器端，切换至刚建好的git用户下，创建.ssh文件和和authorized_keys文件 123su gitmkdir ~/.sshvim ~/.ssh/authorized_keys 然后修改权限 123cd ~chmod 600 .ssh/authorzied_keys # 将文件设置为可读可写chmod 700 .ssh #将该文件夹设置为可读可写可执行（访问） 测试git链接切换到本地机器在本地机器上测试是否能连接到你的远程Git用户 1ssh -v git@SERVER_IP 测试成功会出现如下：如果测试不成功，看看具体的输出信息，通常是公钥没配置好的原因，不用担心，把原来生成的公钥删了，try again 就欧克了 创建网站根目录创建网站的根目录目的是为了让nginx进行托管hexo 生成的静态文件 创建一个目录用于作为网站的根目录，切换到root用 12su rootmkdir /home/hexo # 此目录为网站的根目录 然后变更该目录的所有者 1chown git:git -R /home/hexo 配置nginx安装过程自行度娘就好，编译好nginx后进入nginx的配置文件 1vim conf/nginx.conf 12345678910111213141516171819server&#123; listen 8081; #监听8081端口 server_name 139.159.245.212; #你的服务器名，通常是域名，如果是域名，你就需要监听80端口 root /home/hexo; #网站的根目录,根据自己所建自行修改 location / &#123; &#125; #access_log logs/access.log mylog; error_page 404 /404.html; #配置40x页面 location = /40x.html &#123; &#125; error_page 500 502 503 504 /50x.html; #配置50x页面 location = /50x.html &#123; &#125; &#125; 注意使用 nginx -t 命令检查配置文件的语法是否出错。然后使用 systemctl restart nginx.service 或者 在编译好的nginx目录下使用sbin/nginx -s reload命令重启服务即可 实现自动化部署建立git裸库（就是空的）在root用户下 123su rootcd /home/git # 在 git 用户目录下创建git init --bare blog.git 这时，git 用户的 ~ 目录下就存在一个 blog.git 文件夹，可使用 ls 命令查看。再修改blog.git 的所有者 使用钩子同步网站根目录在这使用的是 post-receive 这个钩子，当 git 有收发的时候就会调用这个钩子。 在 blog.git裸库的 hooks 文件夹中，新建 post-receive 文件。 1vim blog.git/hooks/post-receive 填入以下内容，其中 /home/hexo 为网站目录，根据自己的填入,保存退出。 12#!/bin/shgit --work-tree=/home/hexo --git-dir=/home/git/blog.git checkout -f 该钩子的意思是当本地有提交到服务器时，会将文件放在/home/hexo下 -f这个参数如果在多人协作的博客中可能会引发不好的结果，因为他是强制更新的意思，会将本地版本覆盖掉远程服务器的版本，但是是个人的博客系统就无所谓了 保存后，要赋予这个文件可执行权限。 1chmod +x /home/git/blog.git/hooks/post-receive 本地机器中部署至服务器在本地中，和部署到 github 服务一样，需要先 hexo g 命令生成静态文件，通过 hexo s 命令能够正常进行本地访问，并且确保已经安装了 hexo-deployer-git。 配置Hexohexo 根目录下的 _config.yml 文件，找到 deploy。 1234deploy: type: git repo: git@SERVER:/home/git/blog.git # 填写你的服务器地址 将SERVER替换掉 branch: master # 分支 之后按照正常的流程部署，也可以在hexo项目中添加脚本scripts,脚本内容如下图所示（在package.json文件中添加） 测试自动化部署然后用hexo d 即可推送到远端服务器 然后可以用自己服务器ip访问自己的博客网站了 本次分享就到这儿，有任何问题欢迎留言，我会在第一时间，进行回复！！","categories":[{"name":"教程","slug":"教程","permalink":"http://www.windknows.com/blog/categories/教程/"}],"tags":[{"name":"hexo,blog","slug":"hexo-blog","permalink":"http://www.windknows.com/blog/tags/hexo-blog/"}]},{"title":"使用hexo搭建博客（三）","slug":"hexo-2","date":"2020-02-03T05:40:59.000Z","updated":"2020-02-03T07:23:43.421Z","comments":true,"path":"hexo-2/","link":"","permalink":"http://www.windknows.com/hexo-2/","excerpt":"","text":"部署发行项目前言这篇文章是基于你已经注册了github账号和创建了对应的仓库，通过配置ssh来建立连接 创建Repository创建一个Repository，名称规则为 1username.github.name 然后编辑hexo的配置文件_config.yml,修改如图示地方。repo修改你的仓库地方 生成ssh123$ ssh-keygen -t rsa -C &quot;邮件地址@youremail.com&quot;Generating public/private rsa key pair.Enter file in which to save the key (/Users/your_user_directory/.ssh/id_rsa):&lt;回车&gt; 然后一路回车 .赋值id_rsa.pub文件内容，在github的settings中，点选SSH keys，添加一个key，将内容粘贴进去 测试是否添加成功1ssh -T git@github.com 部署到github上在hexo中分别进行生成，上传 12hexo ghexo d 部署成功后，可通过 http://pangyuanni.github.io 进行访问，其中将pangyuanni替换为你自己的username即可 此次分享到这儿 下篇博客分享如何部署到自己的与服务器上","categories":[{"name":"教程","slug":"教程","permalink":"http://www.windknows.com/blog/categories/教程/"}],"tags":[{"name":"hexo,blog","slug":"hexo-blog","permalink":"http://www.windknows.com/blog/tags/hexo-blog/"}]},{"title":"使用hexo搭建博客（二）","slug":"hexo-1","date":"2020-02-02T02:34:30.000Z","updated":"2020-02-03T07:37:12.419Z","comments":true,"path":"hexo-1/","link":"","permalink":"http://www.windknows.com/hexo-1/","excerpt":"","text":"前言 承接上篇博客，上篇博客中我们已经能够在本地成功运行我们的hexo博客，这篇文章我们来说说hexo的主题等个性化操作 主题 Hexo官网有很多很多主题供我们选择，我们可以在这些主题的基础之下进行修改，或者加入我们个性化的元素，hexo的官网网址是https://hexo.io/zh-cn/， 打开之后是这样，打开之后就是对hexo优点的介绍，然后我们选择主题然后打开就可以看到很多很多主题，由于hexo的服务器在国外加载可能较慢，耐心等待就好。 然后每个主题对应的名字就是主题的github地址，在我们hexo项目文件中找到theme进入之后，使用git clone 加主题的github地址，就可以把相应的主题文件克隆到我们的本地，我用我使用的material-x 这个主题为例，地址是https://github.com/xaoxuu/hexo-theme-material-x.git 1git clone https://github.com/xaoxuu/hexo-theme-material-x.git 这样就能将主题文件克隆到本地，如图示，当然也可以在浏览器里下载然后，解压到你的themes文件夹下 克隆完看看 看看使用说明，有没有相关的依赖包需要下载，若有按照说明进行下载，如 material-x npm i -S hexo-generator-search hexo-generator-json-content hexo-renderer-less Hexo网站配置文件123在根目录下的_config.yml主要是对网站的总属性进行设置如：网站标题，网站logo,网站插件使用等全局的属性主题目录下的_config.yml主要是针对网站的布局，导航等特性设置进行设 启用主题打开站点配置文件（根目录下的_config.yml）找到theme，将其值改为你下载的主题的名字，如下 PS :注意theme的冒号后面有个空格，不然会报错 然后再次启动我们的hexo，打开localshost:4000就可以看到主题效果 这样我们就更换了一个主题 关于网站的配置我们都可在网站的配置文件下更改： 刚更换完主题后，配置文件是这样的： 自己配置完是这样的 title是网站的标题 avatar 是网站的图标， logo是网站的logo， subtitle 是网站副标题 description 是网站描述 author 是作者 timezone 是时区 language 是语言 其他配置暂时可忽略 然后对于其他关于主题的设置可以到themes文件夹下里的主题文件里的_config.yml里面进行相关配置，比如评论系统，字数统计，背景图，等等相关配置都在里面进行配置，在配置文件里都有相关说明。 此次分享就到这儿，下篇博客我们分享如何部署项目","categories":[{"name":"教程","slug":"教程","permalink":"http://www.windknows.com/blog/categories/教程/"}],"tags":[{"name":"hexo，blog","slug":"hexo，blog","permalink":"http://www.windknows.com/blog/tags/hexo，blog/"}]},{"title":"使用hexo 搭建博客(一)","slug":"hexo","date":"2020-01-30T04:09:29.000Z","updated":"2020-02-03T07:27:40.688Z","comments":true,"path":"hexo/","link":"","permalink":"http://www.windknows.com/hexo/","excerpt":"","text":"使用Hexo搭建博客（一）引言： 本来刚开始想用python的django框架进行个人博客的搭建，但是使用python框架进行搭建的话， 但是进行到一半就不想干了，因为代码量太复杂，太繁琐，后来在网上发现了hexo这个专业的博客框架，搭建起来比较django省时省力，就决定用Hexo来搭建，在本地搭建没什么问题，但部署在云服务器的过程异常艰难。但最终，在神器——百度 的帮助下，问题全部解决 Hexo 说明Hexo是基于nodeJS环境的静态博客，简单来说就是轻量，简易，高逼格的博客工具，hexo是将markdown文件生成静态的html然后将生成的html上传到我们的服务器，简而言之：hexo是个静态页面生成，上传的工具 准备环境先安利一个在windows下非常好用的命令行工具cmder,关于他的好用之处，在另一篇博客有详细说明 Node.js 下载后，双击打开安装，也是一路next，不过在Custom Setup这一步记得选 Add to PATH ,这样你就不用自己去配置电脑上环境变量了 Git 下载安装，下载后一路next就好 用npm安装Hexo 1npm install -g hexo-cli // npm是安装Nodejs一起安装的包管理工具 这样我们的hexo在本地就差不多完成了，然后我们新建一个空的文件夹，进去初始化博客（这里我新建一个blog的文件夹）然后输入下列命令 12hexo init # hexo会在目标文件夹简历网站所需要的所有文件npm install # 安装依赖包 也可以使用 hexo init ，其中 为保存Hexo的项目路径，然后就等待clone，就会把各种配置文件下载到你的文件夹中了， 本地启动12hexo g #等同于hexo generate,胜场静态文件到public文件夹hexo s # 等同于hexo server,在本地服务器运行 还有一个命令 1hexo clean #作为清除静态文件夹的内容并删掉，主要用于更改变更了某些地方导致页面显示不完善 之后就可以打开浏览器并输入ip地址http://localhost:4000/查看，效果如下 新建页面和文章12hexo new 'title' #生成新文章，路径在:\\source\\_post\\title.mdhexo new page 'title' #生成新页面,可在主题配置文件中配置页面 生成文章或页面的模板放在博客文件夹根目录下的 scaffolds/ 文件夹里面，文章对应的是 post.md ，页面对应的是page.md，草稿的是draft.md 编辑文章123456789---title: Start My Blog Trip — Power By Hexo # 文章页面上的显示名称，可以任意修改，不会出现在URL中date: 2017-2-10 23:49:28 # 文章生成时间，一般不改categories: diary # 文章分类目录，多个分类使用[a,b,c]这种格式tags: [Hexo,diary] # 文章标签---#这里开始使用markdown格式输入你的正文。&lt;!--more--&gt; #more标签以下的内容要点击“阅读全文”才能看见，#more标签以上的内容为你首页显示文章的摘要部分 Markdown文章编辑如果不熟悉MD语法，可以去百度，B站找教学，不难，常用的语法就那么几个 再给大家安利个md文章神器Typora,还有hexo文章神器HexoEditor 常用命令总结1234567hexo init [folder] # 初始化一个网站。如果没有设置 folder ，Hexo 默认在目前的文件夹建立网站hexo new [layout] &lt;title&gt; # 新建一篇文章。如果没有设置 layout 的话，默认使用 _config.yml 中的 default_layout 参数代替。如果标题包含空格的话，请使用引号括起来hexo version # 查看版本hexo clean # 清除缓存文件 (db.json) 和已生成的静态文件 (public)hexo g # 等于hexo generate # 生成静态文件hexo s # 等于hexo server # 本地预览hexo d # 等于hexo deploy # 部署，可与hexo g合并为 hexo d -g 本篇文章先到这儿，下篇文章给大家分享分享打造个性化的hexo-blog","categories":[{"name":"教程","slug":"教程","permalink":"http://www.windknows.com/blog/categories/教程/"}],"tags":[{"name":"hexo,blog","slug":"hexo-blog","permalink":"http://www.windknows.com/blog/tags/hexo-blog/"}]}]}