{"meta":{"title":"风晓博客","subtitle":"只有飘零的风，知道你所欲所求","description":"一个喜欢瞎玩的博主","author":"风晓","url":"http://www.windknew.com"},"pages":[{"title":"","date":"2020-02-13T01:24:41.611Z","updated":"2020-02-13T01:22:28.549Z","comments":true,"path":"404.html","permalink":"http://www.windknew.com/404.html","excerpt":"","text":"404 body { background: #000; height: 100vh; overflow: hidden; display: flex; font-family: 'Anton', sans-serif; justify-content: center; align-items: center; -webkit-perspective: 1000px; perspective: 1000px; } div { -webkit-transform-style: preserve-3d; transform-style: preserve-3d; } .rail { position: absolute; width: 100%; height: 100%; display: flex; justify-content: center; align-items: center; -webkit-transform: rotateX(-30deg) rotateY(-30deg); transform: rotateX(-30deg) rotateY(-30deg); } .rail .stamp { position: absolute; width: 200px; height: 200px; display: flex; justify-content: center; align-items: center; background: #141414; color: #fff; font-size: 7rem; } .rail .stamp:nth-child(1) { -webkit-animation: stampSlide 40000ms -2300ms linear infinite; animation: stampSlide 40000ms -2300ms linear infinite; } .rail .stamp:nth-child(2) { -webkit-animation: stampSlide 40000ms -4300ms linear infinite; animation: stampSlide 40000ms -4300ms linear infinite; } .rail .stamp:nth-child(3) { -webkit-animation: stampSlide 40000ms -6300ms linear infinite; animation: stampSlide 40000ms -6300ms linear infinite; } .rail .stamp:nth-child(4) { -webkit-animation: stampSlide 40000ms -8300ms linear infinite; animation: stampSlide 40000ms -8300ms linear infinite; } .rail .stamp:nth-child(5) { -webkit-animation: stampSlide 40000ms -10300ms linear infinite; animation: stampSlide 40000ms -10300ms linear infinite; } .rail .stamp:nth-child(6) { -webkit-animation: stampSlide 40000ms -12300ms linear infinite; animation: stampSlide 40000ms -12300ms linear infinite; } .rail .stamp:nth-child(7) { -webkit-animation: stampSlide 40000ms -14300ms linear infinite; animation: stampSlide 40000ms -14300ms linear infinite; } .rail .stamp:nth-child(8) { -webkit-animation: stampSlide 40000ms -16300ms linear infinite; animation: stampSlide 40000ms -16300ms linear infinite; } .rail .stamp:nth-child(9) { -webkit-animation: stampSlide 40000ms -18300ms linear infinite; animation: stampSlide 40000ms -18300ms linear infinite; } .rail .stamp:nth-child(10) { -webkit-animation: stampSlide 40000ms -20300ms linear infinite; animation: stampSlide 40000ms -20300ms linear infinite; } .rail .stamp:nth-child(11) { -webkit-animation: stampSlide 40000ms -22300ms linear infinite; animation: stampSlide 40000ms -22300ms linear infinite; } .rail .stamp:nth-child(12) { -webkit-animation: stampSlide 40000ms -24300ms linear infinite; animation: stampSlide 40000ms -24300ms linear infinite; } .rail .stamp:nth-child(13) { -webkit-animation: stampSlide 40000ms -26300ms linear infinite; animation: stampSlide 40000ms -26300ms linear infinite; } .rail .stamp:nth-child(14) { -webkit-animation: stampSlide 40000ms -28300ms linear infinite; animation: stampSlide 40000ms -28300ms linear infinite; } .rail .stamp:nth-child(15) { -webkit-animation: stampSlide 40000ms -30300ms linear infinite; animation: stampSlide 40000ms -30300ms linear infinite; } .rail .stamp:nth-child(16) { -webkit-animation: stampSlide 40000ms -32300ms linear infinite; animation: stampSlide 40000ms -32300ms linear infinite; } .rail .stamp:nth-child(17) { -webkit-animation: stampSlide 40000ms -34300ms linear infinite; animation: stampSlide 40000ms -34300ms linear infinite; } .rail .stamp:nth-child(18) { -webkit-animation: stampSlide 40000ms -36300ms linear infinite; animation: stampSlide 40000ms -36300ms linear infinite; } .rail .stamp:nth-child(19) { -webkit-animation: stampSlide 40000ms -38300ms linear infinite; animation: stampSlide 40000ms -38300ms linear infinite; } .rail .stamp:nth-child(20) { -webkit-animation: stampSlide 40000ms -40300ms linear infinite; animation: stampSlide 40000ms -40300ms linear infinite; } @-webkit-keyframes stampSlide { 0% { -webkit-transform: rotateX(90deg) rotateZ(-90deg) translateZ(-200px) translateY(130px); transform: rotateX(90deg) rotateZ(-90deg) translateZ(-200px) translateY(130px); } 100% { -webkit-transform: rotateX(90deg) rotateZ(-90deg) translateZ(-200px) translateY(-3870px); transform: rotateX(90deg) rotateZ(-90deg) translateZ(-200px) translateY(-3870px); } } @keyframes stampSlide { 0% { -webkit-transform: rotateX(90deg) rotateZ(-90deg) translateZ(-200px) translateY(130px); transform: rotateX(90deg) rotateZ(-90deg) translateZ(-200px) translateY(130px); } 100% { -webkit-transform: rotateX(90deg) rotateZ(-90deg) translateZ(-200px) translateY(-3870px); transform: rotateX(90deg) rotateZ(-90deg) translateZ(-200px) translateY(-3870px); } } .world { -webkit-transform: rotateX(-30deg) rotateY(-30deg); transform: rotateX(-30deg) rotateY(-30deg); } .world .forward { position: absolute; -webkit-animation: slide 2000ms linear infinite; animation: slide 2000ms linear infinite; } .world .box { width: 200px; height: 200px; -webkit-transform-origin: 100% 100%; transform-origin: 100% 100%; -webkit-animation: roll 2000ms cubic-bezier(1, 0.01, 1, 1) infinite; animation: roll 2000ms cubic-bezier(1, 0.01, 1, 1) infinite; } .world .box .wall { position: absolute; width: 200px; height: 200px; background: rgba(10, 10, 10, 0.8); border: 1px solid #fafafa; box-sizing: border-box; } .world .box .wall::before { content: ''; position: absolute; width: 100%; height: 100%; display: flex; justify-content: center; align-items: center; color: #fff; font-size: 7rem; } .world .box .wall:nth-child(1) { -webkit-transform: translateZ(100px); transform: translateZ(100px); } .world .box .wall:nth-child(2) { -webkit-transform: rotateX(180deg) translateZ(100px); transform: rotateX(180deg) translateZ(100px); } .world .box .wall:nth-child(3) { -webkit-transform: rotateX(90deg) translateZ(100px); transform: rotateX(90deg) translateZ(100px); } .world .box .wall:nth-child(3)::before { -webkit-transform: rotateX(180deg) rotateZ(90deg) translateZ(-1px); transform: rotateX(180deg) rotateZ(90deg) translateZ(-1px); -webkit-animation: zeroFour 4000ms -2000ms linear infinite; animation: zeroFour 4000ms -2000ms linear infinite; } .world .box .wall:nth-child(4) { -webkit-transform: rotateX(-90deg) translateZ(100px); transform: rotateX(-90deg) translateZ(100px); } .world .box .wall:nth-child(4)::before { -webkit-transform: rotateX(180deg) rotateZ(-90deg) translateZ(-1px); transform: rotateX(180deg) rotateZ(-90deg) translateZ(-1px); -webkit-animation: zeroFour 4000ms -2000ms linear infinite; animation: zeroFour 4000ms -2000ms linear infinite; } .world .box .wall:nth-child(5) { -webkit-transform: rotateY(90deg) translateZ(100px); transform: rotateY(90deg) translateZ(100px); } .world .box .wall:nth-child(5)::before { -webkit-transform: rotateX(180deg) translateZ(-1px); transform: rotateX(180deg) translateZ(-1px); -webkit-animation: zeroFour 4000ms linear infinite; animation: zeroFour 4000ms linear infinite; } .world .box .wall:nth-child(6) { -webkit-transform: rotateY(-90deg) translateZ(100px); transform: rotateY(-90deg) translateZ(100px); } .world .box .wall:nth-child(6)::before { -webkit-transform: rotateX(180deg) rotateZ(180deg) translateZ(-1px); transform: rotateX(180deg) rotateZ(180deg) translateZ(-1px); -webkit-animation: zeroFour 4000ms linear infinite; animation: zeroFour 4000ms linear infinite; } @-webkit-keyframes zeroFour { 0% { content: '4'; } 100% { content: '0'; } } @keyframes zeroFour { 0% { content: '4'; } 100% { content: '0'; } } @-webkit-keyframes roll { 0% { -webkit-transform: rotateZ(0deg); transform: rotateZ(0deg); } 85% { -webkit-transform: rotateZ(90deg); transform: rotateZ(90deg); } 87% { -webkit-transform: rotateZ(88deg); transform: rotateZ(88deg); } 90% { -webkit-transform: rotateZ(90deg); transform: rotateZ(90deg); } 100% { -webkit-transform: rotateZ(90deg); transform: rotateZ(90deg); } } @keyframes roll { 0% { -webkit-transform: rotateZ(0deg); transform: rotateZ(0deg); } 85% { -webkit-transform: rotateZ(90deg); transform: rotateZ(90deg); } 87% { -webkit-transform: rotateZ(88deg); transform: rotateZ(88deg); } 90% { -webkit-transform: rotateZ(90deg); transform: rotateZ(90deg); } 100% { -webkit-transform: rotateZ(90deg); transform: rotateZ(90deg); } } @-webkit-keyframes slide { 0% { -webkit-transform: translateX(0); transform: translateX(0); } 100% { -webkit-transform: translateX(-200px); transform: translateX(-200px); } } @keyframes slide { 0% { -webkit-transform: translateX(0); transform: translateX(0); } 100% { -webkit-transform: translateX(-200px); transform: translateX(-200px); } } 4 0 4 0 4 0 4 0 4 0 4 0 4 0 4 0 4 0 4 0"},{"title":"我的朋友们","date":"2020-01-27T05:03:26.134Z","updated":"2020-01-27T05:03:26.128Z","comments":true,"path":"friends/index.html","permalink":"http://www.windknew.com/friends/index.html","excerpt":"","text":"各位大佬想交换友链的话可以在下方留言，必须要有名称、头像链接、和至少一个标签哦～ 名称： 风晓博客头像： http://i2.tiimg.com/708378/9da6ad9df503cebc.jpg网址： https://www.windknows.com标签： iOS"},{"title":"关于","date":"2020-01-27T05:00:25.774Z","updated":"2020-01-27T05:00:25.764Z","comments":true,"path":"about/index.html","permalink":"http://www.windknew.com/about/index.html","excerpt":"","text":"&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 这是第一次搭建的博客，请随意留言，但是我不会回复 One More Thing懒加载占位图如果喜欢请拿去：图片链接 欢迎灌水"},{"title":"","date":"2020-01-23T08:04:56.892Z","updated":"2020-01-23T02:49:33.689Z","comments":true,"path":"projects/index.html","permalink":"http://www.windknew.com/projects/index.html","excerpt":"","text":""},{"title":"所有分类","date":"2020-01-23T08:04:56.891Z","updated":"2020-01-23T02:49:33.686Z","comments":true,"path":"blog/categories/index.html","permalink":"http://www.windknew.com/blog/categories/index.html","excerpt":"","text":""},{"title":"所有标签","date":"2020-01-23T08:04:56.891Z","updated":"2020-01-23T02:49:33.687Z","comments":true,"path":"blog/tags/index.html","permalink":"http://www.windknew.com/blog/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"在家学习java第七天（接口和包）","slug":"java-8","date":"2020-02-13T09:27:58.000Z","updated":"2020-02-20T01:31:31.622Z","comments":true,"path":"java-8/","link":"","permalink":"http://www.windknew.com/java-8/","excerpt":"","text":"Java 接口接口（Interface），在java中，是一个抽象类型，是抽象方法的集合，接口通常以interface来声明，一个类通过继承接口的方式，从而来继承接口的抽象方法 接口并不是类，编写接口的方式和类很相似，但是他门属于不同的概念，类描述对象的属性和方法接口则包含类要实现的方法 除非实现接口的类是抽象类，否则该类要定义接口中的所有方法 接口无法被实例化，但是可以被实现。一个实现接口的类必须实现接口内所描述的所有方法，否则就必须声明为抽象类。另外，在Java中，接口类型可用来声明一个变量，他们可以成为一个空指针，或是被绑定在一个以此接口实现的对象 接口与类的相似点 一个接口可以有多个方法。 接口文件保存在 .java 结尾的文件中，文件名使用接口名。 接口的字节码文件保存在 .class 结尾的文件中。 接口相应的字节码文件必须在与包名称相匹配的目录结构中。 接口与类的区别： 接口不能用于实例化对象。 接口没有构造方法。 接口中所有的方法必须是抽象方法。 接口不能包含成员变量，除了 static 和 final 变量。 接口不是被类继承了，而是要被类实现。 接口支持多继承。 接口特性 接口中每一个方法也是隐式抽象的,接口中的方法会被隐式的指定为 public abstract（只能是 public abstract，其他修饰符都会报错）。 接口中可以含有变量，但是接口中的变量会被隐式的指定为 public static final 变量（并且只能是 public，用 private 修饰会报编译错误）。 接口中的方法是不能在接口中实现的，只能由实现接口的类来实现接口中的方法。 抽象类和接口的区别 抽象类中的方法可以有方法体，就是能实现方法的具体功能，但是接口中的方法不行。 抽象类中的成员变量可以是各种类型的，而接口中的成员变量只能是 public static final 类型的。 接口中不能含有静态代码块以及静态方法(用 static 修饰的方法)，而抽象类是可以有静态代码块和静态方法。 一个类只能继承一个抽象类，而一个类却可以实现多个接口。 注：JDK 1.8 以后，接口里可以有静态方法和方法体了。 接口的声明接口的声明语法格式如下： 1234[可见度] interface 接口名称 [extends 其他的接口名] &#123; // 声明变量 // 抽象方法&#125; Interface关键字用来声明一个接口。下面是接口声明的一个简单例子。 12345678import java.lang.*;//引入包 public interface NameOfInterface&#123; //任何类型 final, static 字段 //抽象方法&#125; 接口有以下特性： 接口是隐式抽象的，当声明一个接口的时候，不必使用abstract关键字。 接口中每一个方法也是隐式抽象的，声明时同样不需要abstract关键字。 接口中的方法都是公有的。 实例12345/* 文件名 : Animal.java */interface Animal &#123; public void eat(); public void travel();&#125; 接口的实现当类实现接口的时候，类要实现接口中所有的方法。否则，类必须声明为抽象的类。 类使用implements关键字实现接口。在类声明中，Implements关键字放在class声明后面。 实现一个接口的语法，可以使用这个公式： 1...implements 接口名称[, 其他接口名称, 其他接口名称..., ...] ... 实例123456789101112131415161718192021/* 文件名 : MammalInt.java */public class MammalInt implements Animal&#123; public void eat()&#123; System.out.println(\"Mammal eats\"); &#125; public void travel()&#123; System.out.println(\"Mammal travels\"); &#125; public int noOfLegs()&#123; return 0; &#125; public static void main(String args[])&#123; MammalInt m = new MammalInt(); m.eat(); m.travel(); &#125;&#125; 结果如下 重写接口中声明的方法时，需要注意以下规则： 类在实现接口的方法时，不能抛出强制性异常，只能在接口中，或者继承接口的抽象类中抛出该强制性异常。 类在重写方法时要保持一致的方法名，并且应该保持相同或者相兼容的返回值类型。 如果实现接口的类是抽象类，那么就没必要实现该接口的方法。 在实现接口的时候，也要注意一些规则： 一个类可以同时实现多个接口。 一个类只能继承一个类，但是能实现多个接口。 一个接口能继承另一个接口，这和类之间的继承比较相似。 接口的继承一个接口能继承另一个接口，和类之间的继承方式比较相似。接口的继承使用extends关键字，子接口继承父接口的方法。 下面的Sports接口被Hockey和Football接口继承： 1234567891011121314151617181920212223// 文件名: Sports.javapublic interface Sports&#123; public void setHomeTeam(String name); public void setVisitingTeam(String name);&#125; // 文件名: Football.javapublic interface Football extends Sports&#123; public void homeTeamScored(int points); public void visitingTeamScored(int points); public void endOfQuarter(int quarter);&#125; // 文件名: Hockey.javapublic interface Hockey extends Sports&#123; public void homeGoalScored(); public void visitingGoalScored(); public void endOfPeriod(int period); public void overtimePeriod(int ot);&#125; Hockey接口自己声明了四个方法，从Sports接口继承了两个方法，这样，实现Hockey接口的类需要实现六个方法。 相似的，实现Football接口的类需要实现五个方法，其中两个来自于Sports接口。 接口的多继承在Java中，类的多继承是不合法，但接口允许多继承。 在接口的多继承中extends关键字只需要使用一次，在其后跟着继承接口。 如下所示： 1public interface Hockey extends Sports, Event 没有任何方法的接口被称为标记接口。标记接口主要用于以下两种目的： 建立一个公共的父接口： 正如EventListener接口，这是由几十个其他接口扩展的Java API，你可以使用一个标记接口来建立一组接口的父接口。例如：当一个接口继承了EventListener接口，Java虚拟机(JVM)就知道该接口将要被用于一个事件的代理方案。 向一个类添加数据类型： 这种情况是标记接口最初的目的，实现标记接口的类不需要定义任何接口方法(因为标记接口根本就没有方法)，但是该类通过多态性变成一个接口类型。 标记接口定义如下： 1234package java.util;public interface EventListener&#123; ....&#125; Java 包（package）为了更好地组织类，Java 提供了包机制，用于区别类名的命名空间。 包的作用 1、把功能相似或相关的类或接口组织在同一个包中，方便类的查找和使用。 2、如同文件夹一样，包也采用了树形目录的存储方式。同一个包中的类名字是不同的，不同的包中的类的名字是可以相同的，当同时调用两个不同包中相同类名的类时，应该加上包名加以区别。因此，包可以避免名字冲突。 3、包也限定了访问权限，拥有包访问权限的类才能访问某个包中的类。 Java 使用包（package）这种机制是为了防止命名冲突，访问控制，提供搜索和定位类（class）、接口、枚举（enumerations）和注释（annotation）等。 包语句的语法格式为： 1package pkg1[．pkg2[．pkg3…]]; 例如,一个Something.java 文件它的内容 1234package net.java.util;public class Something&#123; ...&#125; 那么它的路径应该是 net/java/util/Something.java 这样保存的。 package(包) 的作用是把不同的 java 程序分类保存，更方便的被其他 java 程序调用。 一个包（package）可以定义为一组相互联系的类型（类、接口、枚举和注释），为这些类型提供访问保护和命名空间管理的功能。 以下是一些 Java 中的包： java.lang-打包基础的类 java.io-包含输入输出功能的函数 开发者可以自己把一组类和接口等打包，并定义自己的包。而且在实际开发中这样做是值得提倡的，当你自己完成类的实现之后，将相关的类分组，可以让其他的编程者更容易地确定哪些类、接口、枚举和注释等是相关的。 由于包创建了新的命名空间（namespace），所以不会跟其他包中的任何名字产生命名冲突。使用包这种机制，更容易实现访问控制，并且让定位相关类更加简单。 创建包创建包的时候，你需要为这个包取一个合适的名字。之后，如果其他的一个源文件包含了这个包提供的类、接口、枚举或者注释类型的时候，都必须将这个包的声明放在这个源文件的开头。 包声明应该在源文件的第一行，每个源文件只能有一个包声明，这个文件中的每个类型都应用于它。 如果一个源文件中没有使用包声明，那么其中的类，函数，枚举，注释等将被放在一个无名的包（unnamed package）中。 例子让我们来看一个例子，这个例子创建了一个叫做animals的包。通常使用小写的字母来命名避免与类、接口名字的冲突。 在 animals 包中加入一个接口（interface）： 1234567/* 文件名: Animal.java */package animals; interface Animal &#123; public void eat(); public void travel();&#125; 接下来，在同一个包中加入该接口的实现： 1234567891011121314151617181920212223package animals; /* 文件名 : MammalInt.java */public class MammalInt implements Animal&#123; public void eat()&#123; System.out.println(\"Mammal eats\"); &#125; public void travel()&#123; System.out.println(\"Mammal travels\"); &#125; public int noOfLegs()&#123; return 0; &#125; public static void main(String args[])&#123; MammalInt m = new MammalInt(); m.eat(); m.travel(); &#125;&#125; 然后，编译这两个文件，并把他们放在一个叫做animals的子目录中。 用下面的命令来运行： 12345$ mkdir animals$ cp Animal.class MammalInt.class animals$ java animals/MammalIntMammal eatsMammal travel import 关键字为了能够使用某一个包的成员，我们需要在 Java 程序中明确导入该包。使用 “import” 语句可完成此功能。 在 java 源文件中 import 语句应位于 package 语句之后，所有类的定义之前，可以没有，也可以有多条，其语法格式为： 1import package1[.package2…].(classname|*); 如果在一个包中，一个类想要使用本包中的另一个类，那么该包名可以省略。 例子下面的 payroll 包已经包含了 Employee 类，接下来向 payroll 包中添加一个 Boss 类。Boss 类引用 Employee 类的时候可以不用使用 payroll 前缀，Boss 类的实例如下。 123456789package payroll; public class Boss&#123; public void payEmployee(Employee e) &#123; e.mailCheck(); &#125;&#125; 如果 Boss 类不在 payroll 包中又会怎样？Boss 类必须使用下面几种方法之一来引用其他包中的类。 使用类全名描述，例如： 1payroll.Employee 用 import 关键字引入，使用通配符 “*” 1import payroll.*; 使用 import 关键字引入 Employee 类: 1import payroll.Employee; 类文件中可以包含任意数量的 import 声明。import 声明必须在包声明之后，类声明之前。 package 的目录结构类放在包中会有两种主要的结果： 包名成为类名的一部分，正如我们前面讨论的一样。 包名必须与相应的字节码所在的目录结构相吻合。 下面是管理你自己 java 中文件的一种简单方式： 将类、接口等类型的源码放在一个文本中，这个文件的名字就是这个类型的名字，并以.java作为扩展名。例如： 1234567// 文件名 : Car.java package vehicle; public class Car &#123; // 类实现 &#125; 接下来，把源文件放在一个目录中，这个目录要对应类所在包的名字。 1....\\vehicle\\Car.java 现在，正确的类名和路径将会是如下样子： 类名 -&gt; vehicle.Car 路径名 -&gt; vehicle\\Car.java (在 windows 系统中) 通常，一个公司使用它互联网域名的颠倒形式来作为它的包名.例如：互联网域名是 runoob.com，所有的包名都以 com.runoob 开头。包名中的每一个部分对应一个子目录。 例如：有一个 com.runoob.test 的包，这个包包含一个叫做 Runoob.java 的源文件，那么相应的，应该有如下面的一连串子目录： 1....\\com\\runoob\\test\\Runoob.java 编译的时候，编译器为包中定义的每个类、接口等类型各创建一个不同的输出文件，输出文件的名字就是这个类型的名字，并加上 .class 作为扩展后缀。 例如： 123456789/ 文件名: Runoob.java package com.runoob.test;public class Runoob &#123; &#125;class Google &#123; &#125; 现在，我们用-d选项来编译这个文件，如下： 1$javac -d . Runoob.java 这样会像下面这样放置编译了的文件： 12.\\com\\runoob\\test\\Runoob.class.\\com\\runoob\\test\\Google.class 可以像下面这样来导入所有 \\com\\runoob\\test\\ 中定义的类、接口等： 1import com.runoob.test.*; 编译之后的 .class 文件应该和 .java 源文件一样，它们放置的目录应该跟包的名字对应起来。但是，并不要求 .class 文件的路径跟相应的 .java 的路径一样。你可以分开来安排源码和类的目录。 12&lt;path-one&gt;\\sources\\com\\runoob\\test\\Runoob.java&lt;path-two&gt;\\classes\\com\\runoob\\test\\Google.class 样，你可以将你的类目录分享给其他的编程人员，而不用透露自己的源码。用这种方法管理源码和类文件可以让编译器和java 虚拟机（JVM）可以找到你程序中使用的所有类型。 类目录的绝对路径叫做 class path。设置在系统变量 CLASSPATH 中。编译器和 java 虚拟机通过将 package 名字加到 class path 后来构造 .class 文件的路径。 \\classes 是 class path，package 名字是 com.runoob.test,而编译器和 JVM 会在 \\classes\\com\\runoob\\test 中找 .class 文件。 一个 class path 可能会包含好几个路径，多路径应该用分隔符分开。默认情况下，编译器和 JVM 查找当前目录。JAR 文件按包含 Java 平台相关的类，所以他们的目录默认放在了 class path 中。","categories":[{"name":"java","slug":"java","permalink":"http://www.windknew.com/blog/categories/java/"}],"tags":[{"name":"java","slug":"java","permalink":"http://www.windknew.com/blog/tags/java/"}]},{"title":"在家学习java第六天（抽象类，封装）","slug":"java-6","date":"2020-02-12T09:00:19.000Z","updated":"2020-02-20T01:19:51.723Z","comments":true,"path":"java-6/","link":"","permalink":"http://www.windknew.com/java-6/","excerpt":"","text":"Java 抽象类抽象类 在面向对象中，所有的对象都是通过类来描述的，但是并不是所有的类都是用来描绘对象的，如果一个类中没有包含最够的信息来描绘一个具体的对象，这样的类就是抽象类 抽象类除了不能实例化对象外，类的其他功能依然存在，成员变量，成员方法和构造方法的访问方式和普通类一样 由于抽象类不能实例化对象，所以抽象类u必须被继承，才能被使用， 在Java中抽象类表示的是一种继承关系，一个类只能继承一个抽象类，而一个类却可以实现多个接口 在Java语言中使用abstract class来定义抽象类，如：12345678910111213141516171819202122232425262728293031323334353637383940414243public abstract class Employee&#123; private String name; private String address; private int number; public Employee(String name, String address, int number) &#123; System.out.println(\"Constructing an Employee\"); this.name = name; this.address = address; this.number = number; &#125; public double computePay() &#123; System.out.println(\"Inside Employee computePay\"); return 0.0; &#125; public void mailCheck() &#123; System.out.println(\"Mailing a check to \" + this.name + \" \" + this.address); &#125; public String toString() &#123; return name + \" \" + address + \" \" + number; &#125; public String getName() &#123; return name; &#125; public String getAddress() &#123; return address; &#125; public void setAddress(String newAddress) &#123; address = newAddress; &#125; public int getNumber() &#123; return number; &#125;&#125; 该类和普通类没什么不同，尽管类是抽象类，但是它仍然有3个成员变量，7个成员方法，和一个构造方法，如： 1234567891011public class AbstractDemo&#123; public static void main(String [] args) &#123; /* 以下是不允许的，会引发错误 */ Employee e = new Employee(\"George W.\", \"Houston, TX\", 43); System.out.println(\"\\n Call mailCheck using Employee reference--\"); e.mailCheck(); &#125;&#125; 当编译时会产生以下错误 继承抽象类我们能通过一般的方法继承Employee类 12345678910111213141516171819202122232425262728293031/* 文件名 : Salary.java */public class Salary extends Employee&#123; private double salary; //Annual salary public Salary(String name, String address, int number, double salary) &#123; super(name, address, number); setSalary(salary); &#125; public void mailCheck() &#123; System.out.println(\"Within mailCheck of Salary class \"); System.out.println(\"Mailing check to \" + getName()+\" with salary \"+salary); &#125; public double getSalary() &#123; return salary; &#125; public void setSalary(double newSalary) &#123; if(newSalary &gt;= 0.0) &#123; salary = newSalary; &#125; &#125; public double computePay() &#123; System.out.println(\"Computing salary pay for \" + getName()); return salary/52; &#125;&#125; 尽管我们不能实例化一个Employee类的对象，但是如果我们实例化一个Salary类对象，该对象将从Employee类继承7个成员方法，且通过该方法可以设置获取三个成员变量 123456789101112131415* 文件名 : AbstractDemo.java */public class AbstractDemo&#123; public static void main(String [] args) &#123; Salary s = new Salary(\"Mohd Mohtashim\", \"Ambehta, UP\", 3, 3600.00); Employee e = new Salary(\"John Adams\", \"Boston, MA\", 2, 2400.00); System.out.println(\"Call mailCheck using Salary reference --\"); s.mailCheck(); System.out.println(\"\\n Call mailCheck using Employee reference--\"); e.mailCheck(); &#125;&#125; 运行结果如下： 抽象方法如果你想设计这样一个类，该类包含一个特别的成员方法，该方法的具体实现由它的子类确定，那么你可以在父类中声明该方法为抽象方法。 Abstract 关键字同样可以用来声明抽象方法，抽象方法只包含一个方法名，而没有方法体。 抽象方法没有定义，方法名后面直接跟一个分号，而不是花括号。如： 12345678910public abstract class Employee&#123; private String name; private String address; private int number; public abstract double computePay(); //其余代码&#125; 声明抽象方法会造成以下两个结果： 如果一个类包含抽象方法，那么该类必须是抽象类。 任何子类必须重写父类的抽象方法，或者声明自身为抽象类。 继承抽象方法的子类必须重写该方法。否则，该子类也必须声明为抽象类。最终，必须有子类实现该抽象方法，否则，从最初的父类到最终的子类都不能用来实例化对象。 如果Salary类继承了Employee类，那么它必须实现computePay()方法，如： 123456789101112public class Salary extends Employee&#123; private double salary; // Annual salary public double computePay() &#123; System.out.println(\"Computing salary pay for \" + getName()); return salary/52; &#125; //其余代码&#125; 抽象类总结 抽象类不能被实例化(初学者很容易犯的错)，如果被实例化，就会报错，编译无法通过。只有抽象类的非抽象子类可以创建对象。 抽象类中不一定包含抽象方法，但是有抽象方法的类必定是抽象类。 抽象类中的抽象方法只是声明，不包含方法体，就是不给出方法的具体实现也就是方法的具体功能。 构造方法，类方法（用 static 修饰的方法）不能声明为抽象方法。 抽象类的子类必须给出抽象类中的抽象方法的具体实现，除非该子类也是抽象类。 Java 封装 在面向对象程式设计方法中，封装（英语：Encapsulation）是指一种将抽象性函式接口的实现细节部分包装、隐藏起来的方法。 封装可以被认为是一个保护屏障，防止该类的代码和数据被外部类定义的代码随机访问。 要访问该类的代码和数据，必须通过严格的接口控制。 封装最主要的功能在于我们能修改自己的实现代码，而不用修改那些调用我们代码的程序片段。 适当的封装可以让程式码更容易理解与维护，也加强了程式码的安全性。 封装的优点 良好的封装能够减少耦合。 类内部的结构可以自由修改。 可以对成员变量进行更精确的控制。 隐藏信息，实现细节。 实现Java封装的步骤 修改属性的可见性来限制对属性的访问（一般限制为private），例如： 12345public class Person &#123; private String name; private int age;&#125;这段代码中，将name和age属性设置为私有的，只能本类才能访问，其他类都访问不了，如此就对信息进行了隐藏。 对每个值属性提供对外的公共方法访问，也就是创建一对赋取值方法，用于对私有属性的访问，例如 1234567891011121314151617181920public class Person&#123; private String name; private int age;​ public int getAge()&#123; return age; &#125;​ public String getName()&#123; return name; &#125;​ public void setAge(int age)&#123; this.age = age; &#125;​ public void setName(String name)&#123; this.name = name; &#125;&#125; 采用this关键字是为了解决实例变量（private String name）和局部变量（setName(String name)中的name变量）之间发生的同名的冲突。 实例12345678910111213141516171819202122232425262728293031/* 文件名: EncapTest.java */public class EncapTest&#123; private String name; private String idNum; private int age; public int getAge()&#123; return age; &#125; public String getName()&#123; return name; &#125; public String getIdNum()&#123; return idNum; &#125; public void setAge( int newAge)&#123; age = newAge; &#125; public void setName(String newName)&#123; name = newName; &#125; public void setIdNum( String newId)&#123; idNum = newId; &#125;&#125; 以上实例中public方法是外部类访问该类成员变量的入口。 通常情况下，这些方法被称为getter和setter方法。 因此，任何要访问类中私有成员变量的类都要通过这些getter和setter方法。 通过如下的例子说明EncapTest类的变量怎样被访问： 1234567891011public class RunEncap&#123; public static void main(String args[])&#123; EncapTest encap = new EncapTest(); encap.setName(\"James\"); encap.setAge(20); encap.setIdNum(\"12343ms\"); System.out.print(\"Name : \" + encap.getName()+ \" Age : \"+ encap.getAge()); &#125;&#125; 以上就是今天学到的java内容，java果然博大精深，怪不得人生苦短，我用python，学了几天java深深体会到了python的精炼","categories":[{"name":"java","slug":"java","permalink":"http://www.windknew.com/blog/categories/java/"}],"tags":[{"name":"java","slug":"java","permalink":"http://www.windknew.com/blog/tags/java/"}]},{"title":"在家学习java第五天（Java面向对象-重写与重载和多态）","slug":"java-5","date":"2020-02-11T09:00:19.000Z","updated":"2020-02-13T02:03:50.166Z","comments":true,"path":"java-5/","link":"","permalink":"http://www.windknew.com/java-5/","excerpt":"","text":"重写(Override)重写是子类对父类的允许访问的方法的实现过程进行重新编写, 返回值和形参都不能改变。即外壳不变，核心重写！ 重写的好处在于子类可以根据需要，定义特定于自己的行为。 也就是说子类能够根据需要实现父类的方法。 重写方法不能抛出新的检查异常或者比被重写方法申明更加宽泛的异常。例如： 父类的一个方法申明了一个检查异常 IOException，但是在重写这个方法的时候不能抛出 Exception 异常，因为 Exception 是 IOException 的父类，只能抛出 IOException 的子类异常。 在面向对象原则里，重写意味着可以重写任何现有方法。实例如下： 12345678910111213141516171819202122class Animal&#123; public void move()&#123; System.out.println(\"动物可以移动\"); &#125;&#125; class Dog extends Animal&#123; public void move()&#123; System.out.println(\"狗可以跑和走\"); &#125;&#125; public class TestDog&#123; public static void main(String args[])&#123; Animal a = new Animal(); // Animal 对象 Animal b = new Dog(); // Dog 对象 a.move();// 执行 Animal 类的方法 b.move();//执行 Dog 类的方法 &#125;&#125; 以上实例编译运行结果如下： 12动物可以移动狗可以跑和走 在上面的例子中可以看到，尽管 b 属于 Animal 类型，但是它运行的是 Dog 类的 move方法。 12345678910111213141516171819202122232425class Animal&#123; public void move()&#123; System.out.println(\"动物可以移动\"); &#125;&#125; class Dog extends Animal&#123; public void move()&#123; System.out.println(\"狗可以跑和走\"); &#125; public void bark()&#123; System.out.println(\"狗可以吠叫\"); &#125;&#125; public class TestDog&#123; public static void main(String args[])&#123; Animal a = new Animal(); // Animal 对象 Animal b = new Dog(); // Dog 对象 a.move();// 执行 Animal 类的方法 b.move();//执行 Dog 类的方法 b.bark(); &#125;&#125; 以上实例编译运行结果如下： 12345TestDog.java:30: cannot find symbolsymbol : method bark()location: class Animal b.bark(); ^ 该程序将抛出一个编译错误，因为b的引用类型Animal没有bark方法。 方法的重写规则 参数列表必须完全与被重写方法的相同。 返回类型与被重写方法的返回类型可以不相同，但是必须是父类返回值的派生类（java5 及更早版本返回类型要一样，java7 及更高版本可以不同）。 访问权限不能比父类中被重写的方法的访问权限更低。例如：如果父类的一个方法被声明为 public，那么在子类中重写该方法就不能声明为 protected。 父类的成员方法只能被它的子类重写。 声明为 final 的方法不能被重写。 声明为 static 的方法不能被重写，但是能够被再次声明。 子类和父类在同一个包中，那么子类可以重写父类所有方法，除了声明为 private 和 final 的方法。 子类和父类不在同一个包中，那么子类只能够重写父类的声明为 public 和 protected 的非 final 方法。 重写的方法能够抛出任何非强制异常，无论被重写的方法是否抛出异常。但是，重写的方法不能抛出新的强制性异常，或者比被重写方法声明的更广泛的强制性异常，反之则可以。 构造方法不能被重写。 如果不能继承一个方法，则不能重写这个方法。 Super 关键字的使用当需要在子类中调用父类的被重写方法时，要使用 super 关键 123456789101112131415161718192021class Animal&#123; public void move()&#123; System.out.println(\"动物可以移动\"); &#125;&#125; class Dog extends Animal&#123; public void move()&#123; super.move(); // 应用super类的方法 System.out.println(\"狗可以跑和走\"); &#125;&#125; public class TestDog&#123; public static void main(String args[])&#123; Animal b = new Dog(); // Dog 对象 b.move(); //执行 Dog类的方法 &#125;&#125; 以上实例编译运行结果如下： 12动物可以移动狗可以跑和走 重载(Overload)重载(overloading) 是在一个类里面，方法名字相同，而参数不同。返回类型可以相同也可以不同。 每个重载的方法（或者构造函数）都必须有一个独一无二的参数类型列表。 最常用的地方就是构造器的重载。 重载规则: 被重载的方法必须改变参数列表(参数个数或类型不一样)； 被重载的方法可以改变返回类型； 被重载的方法可以改变访问修饰符； 被重载的方法可以声明新的或更广的检查异常； 方法能够在同一个类中或者在一个子类中被重载。 无法以返回值类型作为重载函数的区分标准。 1234567891011121314151617181920212223242526272829public class Overloading &#123; public int test()&#123; System.out.println(\"test1\"); return 1; &#125; public void test(int a)&#123; System.out.println(\"test2\"); &#125; //以下两个参数类型顺序不同 public String test(int a,String s)&#123; System.out.println(\"test3\"); return \"returntest3\"; &#125; public String test(String s,int a)&#123; System.out.println(\"test4\"); return \"returntest4\"; &#125; public static void main(String[] args)&#123; Overloading o = new Overloading(); System.out.println(o.test()); o.test(1); System.out.println(o.test(1,\"test3\")); System.out.println(o.test(\"test4\",1)); &#125;&#125; 结果如下： 12345678910Compiling Overloading.java.......-----------OUTPUT-----------test11test2test3returntest3test4returntest4[Finished in 1.4s] 重写与重载之间的区别 区别点 重载方法 重写方法 参数列表 必须修改 一定不能修改 返回类型 可以修改 一定不能修改 异常 可以修改 可以减少或删除，一定不能抛出新的或者更广的异常 访问 可以修改 一定不能做更严格的限制（可以降低限制） 总结方法的重写(Overriding)和重载(Overloading)是java多态性的不同表现，重写是父类与子类之间多态性的一种表现，重载可以理解成多态的具体表现形式。 (1)方法重载是一个类中定义了多个方法名相同,而他们的参数的数量不同或数量相同而类型和次序不同,则称为方法的重载(Overloading)。 (2)方法重写是在子类存在方法与父类的方法的名字相同,而且参数的个数与类型一样,返回值也一样的方法,就称为重写(Overriding)。 (3)方法重载是一个类的多态性表现,而方法重写是子类与父类的一种多态性表现。 多态多态是同一个行为具有多个不同表现形式或形态的能力。 多态就是同一个接口，使用不同的实例而执行不同操作 比如键盘上的按键，在不同应用有不同的功能 多态的优点 消除类型之间的耦合关系 可替换性 可扩充性 接口性 灵活性 简化性 多态存在的三个必要条件 继承 重写 父类引用指向子类对象 比如： 1Parent p = new Child(); 当使用多态方式调用方法时，首先检查父类中是否有该方法，如果没有，则编译错误；如果有，再去调用子类的同名方法。 多态的好处：可以使程序有良好的扩展，并可以对所有类的对象进行通用处理。 如下列多态例子: 123456789101112131415161718192021222324252627282930313233343536373839404142434445public class Test &#123; public static void main(String[] args) &#123; show(new Cat()); // 以 Cat 对象调用 show 方法 show(new Dog()); // 以 Dog 对象调用 show 方法 Animal a = new Cat(); // 向上转型 a.eat(); // 调用的是 Cat 的 eat Cat c = (Cat)a; // 向下转型 c.work(); // 调用的是 Cat 的 work &#125; public static void show(Animal a) &#123; a.eat(); // 类型判断 if (a instanceof Cat) &#123; // 猫做的事情 Cat c = (Cat)a; c.work(); &#125; else if (a instanceof Dog) &#123; // 狗做的事情 Dog c = (Dog)a; c.work(); &#125; &#125; &#125; abstract class Animal &#123; abstract void eat(); &#125; class Cat extends Animal &#123; public void eat() &#123; System.out.println(\"吃鱼\"); &#125; public void work() &#123; System.out.println(\"抓老鼠\"); &#125; &#125; class Dog extends Animal &#123; public void eat() &#123; System.out.println(\"吃骨头\"); &#125; public void work() &#123; System.out.println(\"看家\"); &#125; &#125; 执行以上程序，输出结果为： 123456吃鱼抓老鼠吃骨头看家吃鱼抓老鼠 虚函数虚函数的存在是为了多态。 Java 中其实没有虚函数的概念，它的普通函数就相当于 C++ 的虚函数，动态绑定是Java的默认行为。如果 Java 中不希望某个函数具有虚函数特性，可以加上 final 关键字变成非虚函数。 重写我们将介绍在 Java 中，当设计类时，被重写的方法的行为怎样影响多态性。 我们已经讨论了方法的重写，也就是子类能够重写父类的方法。 当子类对象调用重写的方法时，调用的是子类的方法，而不是父类中被重写的方法。 要想调用父类中被重写的方法，则必须使用关键字 super。如下： 12345678910111213141516171819202122232425262728293031/* 文件名 : Employee.java */public class Employee &#123; private String name; private String address; private int number; public Employee(String name, String address, int number) &#123; System.out.println(\"Employee 构造函数\"); this.name = name; this.address = address; this.number = number; &#125; public void mailCheck() &#123; System.out.println(\"邮寄支票给： \" + this.name + \" \" + this.address); &#125; public String toString() &#123; return name + \" \" + address + \" \" + number; &#125; public String getName() &#123; return name; &#125; public String getAddress() &#123; return address; &#125; public void setAddress(String newAddress) &#123; address = newAddress; &#125; public int getNumber() &#123; return number; &#125;&#125; 假设下面的类继承Employee类： 1234567891011121314151617181920212223242526/* 文件名 : Salary.java */public class Salary extends Employee&#123; private double salary; // 全年工资 public Salary(String name, String address, int number, double salary) &#123; super(name, address, number); setSalary(salary); &#125; public void mailCheck() &#123; System.out.println(\"Salary 类的 mailCheck 方法 \"); System.out.println(\"邮寄支票给：\" + getName() + \" ，工资为：\" + salary); &#125; public double getSalary() &#123; return salary; &#125; public void setSalary(double newSalary) &#123; if(newSalary &gt;= 0.0) &#123; salary = newSalary; &#125; &#125; public double computePay() &#123; System.out.println(\"计算工资，付给：\" + getName()); return salary/52; &#125;&#125; 1234567891011/* 文件名 : VirtualDemo.java */public class VirtualDemo &#123; public static void main(String [] args) &#123; Salary s = new Salary(\"员工 A\", \"北京\", 3, 3600.00); Employee e = new Salary(\"员工 B\", \"上海\", 2, 2400.00); System.out.println(\"使用 Salary 的引用调用 mailCheck -- \"); s.mailCheck(); System.out.println(\"\\n使用 Employee 的引用调用 mailCheck--\"); e.mailCheck(); &#125;&#125; 以上实例编译运行结果如下： 123456789Employee 构造函数Employee 构造函数使用 Salary 的引用调用 mailCheck -- Salary 类的 mailCheck 方法 邮寄支票给：员工 A ，工资为：3600.0使用 Employee 的引用调用 mailCheck--Salary 类的 mailCheck 方法 邮寄支票给：员工 B ，工资为：2400.0 例子解析 实例中，实例化了两个 Salary 对象：一个使用 Salary 引用 s，另一个使用 Employee 引用 e。 当调用 s.mailCheck() 时，编译器在编译时会在 Salary 类中找到 mailCheck()，执行过程 JVM 就调用 Salary 类的 mailCheck()。 因为 e 是 Employee 的引用，所以调用 e 的 mailCheck() 方法时，编译器会去 Employee 类查找 mailCheck() 方法 。 在编译的时候，编译器使用 Employee 类中的 mailCheck() 方法验证该语句， 但是在运行的时候，Java虚拟机(JVM)调用的是 Salary 类中的 mailCheck() 方法。 以上整个过程被称为虚拟方法调用，该方法被称为虚拟方法。 Java中所有的方法都能以这种方式表现，因此，重写的方法能在运行时调用，不管编译的时候源代码中引用变量是什么数据类型。 态的实现方式方式一：重写：就是java重写与重载 方式二：接口 生活中的接口最具代表性的就是插座，例如一个三接头的插头都能接在三孔插座中，因为这个是每个国家都有各自规定的接口规则，有可能到国外就不行，那是因为国外自己定义的接口类型。 java中的接口类似于生活中的接口，就是一些方法特征的集合，但没有方法的实现。具体可以看 java接口 这一章节的内容。","categories":[{"name":"java","slug":"java","permalink":"http://www.windknew.com/blog/categories/java/"}],"tags":[{"name":"java","slug":"java","permalink":"http://www.windknew.com/blog/tags/java/"}]},{"title":"在家学习java第五天（Java面向对象-继承）","slug":"java-4","date":"2020-02-10T09:38:11.000Z","updated":"2020-02-13T02:03:54.003Z","comments":true,"path":"java-4/","link":"","permalink":"http://www.windknew.com/java-4/","excerpt":"","text":"Java继承继承的概念继承时java面向对象编程技术的一块基石，因为它允许创建分等级层次的类 继承就是子类继承父类的特征和行为，使得子类对象具有父类的实例域和方法，或子类从父类集成方法，使得子类具有父亲相同的行为 类的继承格式在java中通过extends关键字可以申明一个类是从另一个类继承而来的，一般形式如下： 12345class 父类 &#123;&#125; class 子类 extends 父类 &#123;&#125; 类的好处开发动物类，其中动物分别为企鹅以及老鼠，要求如下： 企鹅：属性（姓名，id），方法（吃，睡，自我介绍） 老鼠：属性（姓名，id），方法（吃，睡，自我介绍） 企鹅类： 1234567891011121314151617public class Penguin &#123; private String name; private int id; public Penguin(String myName, int myid) &#123; name = myName; id = myid; &#125; public void eat()&#123; System.out.println(name+\"正在吃\"); &#125; public void sleep()&#123; System.out.println(name+\"正在睡\"); &#125; public void introduction() &#123; System.out.println(\"大家好！我是\" + id + \"号\" + name + \".\"); &#125; &#125; 老鼠类： 1234567891011121314151617public class Mouse &#123; private String name; private int id; public Mouse(String myName, int myid) &#123; name = myName; id = myid; &#125; public void eat()&#123; System.out.println(name+\"正在吃\"); &#125; public void sleep()&#123; System.out.println(name+\"正在睡\"); &#125; public void introduction() &#123; System.out.println(\"大家好！我是\" + id + \"号\" + name + \".\"); &#125; &#125; 从这两段代码可以看出来，代码存在重复了，所以要解决这两段代码的问题，就需要继承，将两段代码中相同的部分提取出来组成 一个父类： 公共父类 1234567891011121314151617public class Animal &#123; private String name; private int id; public Animal(String myName, int myid) &#123; name = myName; id = myid; &#125; public void eat()&#123; System.out.println(name+\"正在吃\"); &#125; public void sleep()&#123; System.out.println(name+\"正在睡\"); &#125; public void introduction() &#123; System.out.println(\"大家好！我是\" + id + \"号\" + name + \".\"); &#125; &#125; 这个Animal类就可以作为一个父类，然后企鹅类和老鼠类继承这个类之后，就具有父类当中的属性和方法，子类就不会存在重复的代码，维护性也提高，代码也更加简洁，提高代码的复用性（复用性主要是可以多次使用，不用再多次写同样的代码） 继承之后的代码： 企鹅类 12345public class Penguin extends Animal &#123; public Penguin(String myName, int myid) &#123; super(myName, myid); &#125; &#125; 老鼠类 12345public class Mouse extends Animal &#123; public Mouse(String myName, int myid) &#123; super(myName, myid); &#125; &#125; 继承类型需要注意的是 Java 不支持多继承，但支持多重继承。 继承的特性 子类拥有父类非 private 的属性、方法。 子类可以拥有自己的属性和方法，即子类可以对父类进行扩展。 子类可以用自己的方式实现父类的方法。 Java 的继承是单继承，但是可以多重继承，单继承就是一个子类只能继承一个父类，多重继承就是，例如 A 类继承 B 类，B 类继承 C 类，所以按照关系就是 C 类是 B 类的父类，B 类是 A 类的父类，这是 Java 继承区别于 C++ 继承的一个特性。 提高了类之间的耦合性（继承的缺点，耦合度高就会造成代码之间的联系越紧密，代码独立性越差）。 继承可以使用 extends 和 implements 这两个关键字来实现继承，而且所有的类都是继承于 java.lang.Object，当一个类没有继承的两个关键字，则默认继承object（这个类在 java.lang 包中，所以不需要 import）祖先类。 extends关键字在 Java 中，类的继承是单一继承，也就是说，一个子类只能拥有一个父类，所以 extends 只能继承一个类。 123456789101112public class Animal &#123; private String name; private int id; public Animal(String myName, String myid) &#123; //初始化属性值 &#125; public void eat() &#123; //吃东西方法的具体实现 &#125; public void sleep() &#123; //睡觉方法的具体实现 &#125; &#125; public class Penguin extends Animal&#123; &#125; implements关键字使用 implements 关键字可以变相的使java具有多继承的特性，使用范围为类继承接口的情况，可以同时继承多个接口（接口跟接口之间采用逗号分隔）。 1234567891011public interface A &#123; public void eat(); public void sleep();&#125; public interface B &#123; public void show();&#125; public class C implements A,B &#123;&#125; super 与 this 关键字super关键字：我们可以通过super关键字来实现对父类成员的访问，用来引用当前对象的父类。 this关键字：指向自己的引用。 123456789101112131415161718192021222324class Animal &#123; void eat() &#123; System.out.println(\"animal : eat\"); &#125;&#125; class Dog extends Animal &#123; void eat() &#123; System.out.println(\"dog : eat\"); &#125; void eatTest() &#123; this.eat(); // this 调用自己的方法 super.eat(); // super 调用父类方法 &#125;&#125; public class Test &#123; public static void main(String[] args) &#123; Animal a = new Animal(); a.eat(); Dog d = new Dog(); d.eatTest(); &#125;&#125; 输出结果为： 123animal : eatdog : eatanimal : eat final关键字final 关键字声明类可以把类定义为不能继承的，即最终类；或者用于修饰方法，该方法不能被子类重写： 声明类： 1final class 类名 &#123;//类体&#125; 声明方法： 1修饰符(public/private/default/protected) final 返回值类型 方法名()&#123;//方法体&#125; 注:实例变量也可以被定义为 final，被定义为 final 的变量不能被修改。被声明为 final 类的方法自动地声明为 final，但是实例变量并不是 final 构造器子类是不继承父类的构造器（构造方法或者构造函数）的，它只是调用（隐式或显式）。如果父类的构造器带有参数，则必须在子类的构造器中显式地通过 super 关键字调用父类的构造器并配以适当的参数列表。 如果父类构造器没有参数，则在子类的构造器中不需要使用 super 关键字调用父类构造器，系统会自动调用父类的无参构造器。 实例123456789101112131415161718192021222324252627282930313233343536373839404142434445464748class SuperClass &#123; private int n; SuperClass()&#123; System.out.println(\"SuperClass()\"); &#125; SuperClass(int n) &#123; System.out.println(\"SuperClass(int n)\"); this.n = n; &#125;&#125;// SubClass 类继承class SubClass extends SuperClass&#123; private int n; SubClass()&#123; // 自动调用父类的无参数构造器 System.out.println(\"SubClass\"); &#125; public SubClass(int n)&#123; super(300); // 调用父类中带有参数的构造器 System.out.println(\"SubClass(int n):\"+n); this.n = n; &#125;&#125;// SubClass2 类继承class SubClass2 extends SuperClass&#123; private int n; SubClass2()&#123; super(300); // 调用父类中带有参数的构造器 System.out.println(\"SubClass2\"); &#125; public SubClass2(int n)&#123; // 自动调用父类的无参数构造器 System.out.println(\"SubClass2(int n):\"+n); this.n = n; &#125;&#125;public class TestSuperSub&#123; public static void main (String args[])&#123; System.out.println(\"------SubClass 类继承------\"); SubClass sc1 = new SubClass(); SubClass sc2 = new SubClass(100); System.out.println(\"------SubClass2 类继承------\"); SubClass2 sc3 = new SubClass2(); SubClass2 sc4 = new SubClass2(200); &#125;&#125; 输出结果为： 12345678910------SubClass 类继承------SuperClass()SubClassSuperClass(int n)SubClass(int n):100------SubClass2 类继承------SuperClass(int n)SubClass2SuperClass()SubClass2(int n):200","categories":[{"name":"java","slug":"java","permalink":"http://www.windknew.com/blog/categories/java/"}],"tags":[{"name":"学习","slug":"学习","permalink":"http://www.windknew.com/blog/tags/学习/"},{"name":"java","slug":"java","permalink":"http://www.windknew.com/blog/tags/java/"}]},{"title":"在家学习lava第四天（修饰符）","slug":"java-3","date":"2020-02-09T09:52:56.000Z","updated":"2020-02-13T02:03:57.402Z","comments":true,"path":"java-3/","link":"","permalink":"http://www.windknew.com/java-3/","excerpt":"","text":"Java 修饰符Java语言提供了很多修饰符，主要分为一下两类： 访问修饰符 非访问修饰符 修饰符用来定义类，方法或者变量，通常放在语句的最前端，例如： 123456789public class Classname&#123; //...&#125;private boollean myFlag;static final double weeks = 9.5;pritected static final int BOXWIDTH = 42;public static void main(String[] arguments)&#123; //方法体&#125; 访问控制修饰符Java中，可以使用访问控制符来保护对类，变量，方法和构造方法的访问，Java支持4种不同的访问权限。 default(即默认，什么也不写)：在同一包内可见，不使用任何修饰符，适用对象：类、接口、变量、方法。 private：在同一类内可见，使用对象：变量，方法。注意不能修饰类（外部类） public：都所有类可见。使用对象：类，接口，变量，方法 protected：对同一包内的类和所有子类可见，使用对象：变量，方法。(注意不能修饰类（外部类）) 访问控制 修饰符 当前类 同一包内 子孙类(同一包) 子孙类(不同包) 其他包 public Y Y Y Y Y protected Y Y Y Y/N（说明） N default Y Y Y N N private Y N N N N 默认访问修饰符-不使用任何关键字 使用默认访问修饰符声明的变量和方法，对同一个包内的类是可见的，接口里的变量都隐式声明为public static final而接口里的方法默认情况下的访问权限是public如下变量和方法的声明可以不使用任何修饰符 1234String version = \"1.5.1\";boolean processOrder()&#123; return true;&#125; 私有访问修饰符-private私有访问修饰符时最严格的访问级别，所以被声明为private的方法，变量和构造方法只能被所属类访问，并且类和接口不能声明为private 声明为私有访问类型的变量只能通过类中公共的getter方法被外部类访问 Private访问修饰符的使用主要用来隐藏类的实现细节和保护类的数据，如下： 123456789publuic class ligger&#123; private String format; public String getFormat()&#123; return this.format; &#125; public void setFormat(String format)&#123; this.format = format; &#125;&#125; 实例中，Logger类中的format变量为私有变量，所以其他类不能直接得到和设置该变量的值，为了使其他类能够操作该变量，定义了两个public方法：getFormat()（返回format的值）和setFormat(String)（设置format的值） 公有访问修饰符-public被声明为public的类、方法、构造方法和接口能够被任何其他类访问 如果几个相互访问的public类分布在不同的包中，则需要导入相应的public类所在的包。由于类的继承性，类所有的公有方法和变量都能被其子类继承。 以下函数使用了公有访问控制： 123public static void main(String[] arguments) &#123; // ...&#125; Java 程序的 main() 方法必须设置成公有的，否则，Java 解释器将不能运行该类。 受保护的访问修饰符-protectedprotected 需要从以下两个点来分析说明： 子类与基类在同一包中：被声明为 protected 的变量、方法和构造器能被同一个包中的任何其他类访问； 子类与基类不在同一包中：那么在子类中，子类实例可以访问其从基类继承而来的 protected 方法，而不能访问基类实例的protected方法。 protected 可以修饰数据成员，构造方法，方法成员，不能修饰类（内部类除外）。 接口及接口的成员变量和成员方法不能声明为 protected。 可以看看下图演示： 子类能访问 protected 修饰符声明的方法和变量，这样就能保护不相关的类使用这些方法和变量。 下面的父类使用了 protected 访问修饰符，子类重写了父类的 openSpeaker() 方法: 1234567891011class AudioPlayer &#123; protected boolean openSpeaker(Speaker sp) &#123; // 实现细节 &#125;&#125; class StreamingAudioPlayer extends AudioPlayer &#123; protected boolean openSpeaker(Speaker sp) &#123; // 实现细节 &#125;&#125; 如果把 openSpeaker() 方法声明为 private，那么除了 AudioPlayer 之外的类将不能访问该方法。 如果把 openSpeaker() 声明为 public，那么所有的类都能够访问该方法。 如果我们只想让该方法对其所在类的子类可见，则将该方法声明为 protected。 访问控制和继承请注意以下方法继承的规则： 父类中声明为 public 的方法在子类中也必须为 public。 父类中声明为 protected 的方法在子类中要么声明为 protected，要么声明为 public，不能声明为 private。 父类中声明为 private 的方法，不能够被继承。 非访问修饰符为了实现一些其他的功能，Java 也提供了许多非访问修饰符。 static 修饰符，用来修饰类方法和类变量。 final 修饰符，用来修饰类、方法和变量，final 修饰的类不能够被继承，修饰的方法不能被继承类重新定义，修饰的变量为常量，是不可修改的。 abstract 修饰符，用来创建抽象类和抽象方法。 synchronized 和 volatile 修饰符，主要用于线程的编程。 static 修饰符 静态变量： static 关键字用来声明独立于对象的静态变量，无论一个类实例化多少对象，它的静态变量只有一份拷贝。 静态变量也被称为类变量。局部变量不能被声明为 static 变量。 静态方法： static 关键字用来声明独立于对象的静态方法。静态方法不能使用类的非静态变量。静态方法从参数列表得到数据，然后计算这些数据。 对类变量和方法的访问可以直接使用 classname.variablename 和 classname.methodname 的方式访问。 如下例所示，static修饰符用来创建类方法和类变量。 123456789101112131415161718192021222324public class InstanceCounter &#123; private static int numInstances = 0; protected static int getCount() &#123; return numInstances; &#125; private static void addInstance() &#123; numInstances++; &#125; InstanceCounter() &#123; InstanceCounter.addInstance(); &#125; public static void main(String[] arguments) &#123; System.out.println(\"Starting with \" + InstanceCounter.getCount() + \" instances\"); for (int i = 0; i &lt; 500; ++i)&#123; new InstanceCounter(); &#125; System.out.println(\"Created \" + InstanceCounter.getCount() + \" instances\"); &#125;&#125; 以上实例运行编辑结果如下: 12Starting with 0 instancesCreated 500 instances final 修饰符final 变量： final 表示”最后的、最终的”含义，变量一旦赋值后，不能被重新赋值。被 final 修饰的实例变量必须显式指定初始值。 final 修饰符通常和 static 修饰符一起使用来创建类常量。 12345678910public class Test&#123; final int value = 10; // 下面是声明常量的实例 public static final int BOXWIDTH = 6; static final String TITLE = \"Manager\"; public void changeValue()&#123; value = 12; //将输出一个错误 &#125;&#125; final 方法 父类中的 final 方法可以被子类继承，但是不能被子类重写。 声明 final 方法的主要目的是防止该方法的内容被修改。 如下所示，使用 final 修饰符声明方法。 12345public class Test&#123; public final void changeName()&#123; // 方法体 &#125;&#125; final 类 final 类不能被继承，没有类能够继承 final 类的任何特性。 123public final class Test &#123; // 类体&#125; abstract 修饰符抽象类：抽象类不能用来实例化对象，声明抽象类的唯一目的是为了将来对该类进行扩充。 一个类不能同时被 abstract 和 final 修饰。如果一个类包含抽象方法，那么该类一定要声明为抽象类，否则将出现编译错误。 抽象类可以包含抽象方法和非抽象方法。 1234567abstract class Caravan&#123; private double price; private String model; private String year; public abstract void goFast(); //抽象方法 public abstract void changeColor();&#125; 抽象方法 抽象方法是一种没有任何实现的方法，该方法的的具体实现由子类提供。 抽象方法不能被声明成 final 和 static。 任何继承抽象类的子类必须实现父类的所有抽象方法，除非该子类也是抽象类。 如果一个类包含若干个抽象方法，那么该类必须声明为抽象类。抽象类可以不包含抽象方法。 抽象方法的声明以分号结尾，例如：public abstract sample();。 12345678910public abstract class SuperClass&#123; abstract void m(); //抽象方法&#125; class SubClass extends SuperClass&#123; //实现抽象方法 void m()&#123; ......... &#125;&#125; synchronized 修饰符synchronized 关键字声明的方法同一时间只能被一个线程访问。synchronized 修饰符可以应用于四个访问修饰 123public synchronized void showDetails()&#123;.......&#125; transient 修饰符序列化的对象包含被 transient 修饰的实例变量时，java 虚拟机(JVM)跳过该特定的变量。 该修饰符包含在定义变量的语句中，用来预处理类和变量的数据类型。 12public transient int limit = 55; // 不会持久化public int b; // 持久化 volatile 修饰符volatile 修饰的成员变量在每次被线程访问时，都强制从共享内存中重新读取该成员变量的值。而且，当成员变量发生变化时，会强制线程将变化值回写到共享内存。这样在任何时刻，两个不同的线程总是看到某个成员变量的同一个值。 一个 volatile 对象引用可能是 null。 12345678910111213141516public class MyRunnable implements Runnable&#123; private volatile boolean active; public void run() &#123; active = true; while (active) // 第一行 &#123; // 代码 &#125; &#125; public void stop() &#123; active = false; // 第二行 &#125;&#125; 通常情况下，在一个线程调用 run() 方法（在 Runnable 开启的线程），在另一个线程调用 stop() 方法。 如果 第一行 中缓冲区的 active 值被使用，那么在 第二行 的 active 值为 false 时循环不会停止。 但是以上代码中我们使用了 volatile 修饰 active，所以该循环会停止","categories":[{"name":"java","slug":"java","permalink":"http://www.windknew.com/blog/categories/java/"}],"tags":[{"name":"学习","slug":"学习","permalink":"http://www.windknew.com/blog/tags/学习/"},{"name":"java","slug":"java","permalink":"http://www.windknew.com/blog/tags/java/"}]},{"title":"在家学习lava第三天（类和对象）","slug":"java-2","date":"2020-02-08T09:54:48.000Z","updated":"2020-02-13T02:04:00.436Z","comments":true,"path":"java-2/","link":"","permalink":"http://www.windknew.com/java-2/","excerpt":"","text":"前言在家无聊学习java第三天 内容java对象和类 类：类是一个模板，它描述一类对象的行为和状态 对象： 对象是类的一个实例，有状态和行为，比如，一条狗是一个对象，他的状态有：颜色，名字，品种，行为有：摇尾巴，叫，吃等 对比现实对象和软件对象，他们之间十分相似，软件对象也有状态和行为，软件对象的状态就是属性，行为就是具体的方法，在软件开发中，方法操作对象内部的状态，队形的相互调用也是通过方法来实现 Java中的类如： 12345678910111213public class Dog&#123; String breed; int age; String color; void barking()&#123; &#125; void hungry()&#123; &#125; void sleeping()&#123; &#125;&#125; 一个类可以包含以下类型变量： 局部变量：在方法、构造方法或者语句块中定义的变量被称为局部变量。变量声明和初始化都是在方法中，方法结束后，变量就会自动销毁。 成员变量：成员变量是定义在类中，方法体之外的变量。这种变量在创建对象的时候实例化。成员变量可以被类中方法、构造方法和特定类的语句块访问。 类变量：类变量也声明在类中，方法体之外，但必须声明为static类型。 一个类可以拥有多个方法，在上面的例子中：barking()、hungry()和sleeping()都是Dog类的方法。 构造方法每个类都有构造方法，如果没有显式地为类定义构造方法。java编译器将会为该类提供一个默认构造方法，在创建一个对象的时候，至少要调用一个构造方法，构造方法的名称必须与类同名，一个类可以有多个构造方法如： 1234567public class Puppy&#123; public Puppy()&#123; &#125; public Puppy(String name)&#123; // 这个构造器仅有一个参数：name &#125;&#125; 创建对象对象是根据类创建的。在java中，使用关键字来创建一个新的对象。创建对象需要以下三步： 声明：声明一个对象，包括对象名称和对象类型。 实例化： 使用关键字new来创建一个对象 初始化 ：使用new创建对象时，会调用构造方法初始化对象 如： 12345678910public class Puppy&#123; public Puppy(String name)&#123; //这个构造器仅有一个参数：name System.out.println(\"小狗的名字是：\"+name); &#125; public static void main(String[] args)&#123; // 下面语句将创建一个Puppy对象 Puppy myPuppy = new Puppy(\"tommy\"); &#125;&#125;","categories":[{"name":"java","slug":"java","permalink":"http://www.windknew.com/blog/categories/java/"}],"tags":[{"name":"学习","slug":"学习","permalink":"http://www.windknew.com/blog/tags/学习/"},{"name":"java","slug":"java","permalink":"http://www.windknew.com/blog/tags/java/"}]},{"title":"在家学习java第二天（常量和变量）","slug":"java-1","date":"2020-02-07T09:25:25.000Z","updated":"2020-02-13T02:04:03.300Z","comments":true,"path":"java-1/","link":"","permalink":"http://www.windknew.com/java-1/","excerpt":"","text":"前言在家无聊学习java第二天 内容常量 字符串常量 整数常量 浮点数常量 字符常量 布尔常量 空常量：null 1234567891011121314151617181920212223242526272829public class TwodayDemo1&#123; public static void main(String[] args)&#123; //字符串常量 System.out.println(\"ABC\"); System.out.println(\"\"); System.out.println(\"XYZ\"); //整数常量 System.out.println(30); System.out.println(-30); //浮点数常量（小数） System.out.println(3.14); System.out.println(-2.5); //字符常量 System.out.println('A'); System.out.println('6'); //System.out.println(''); 两个单引号中间必须有且仅有一个字符，没有就会报错 //System.out.println('AB') 有两个字符也不行 //布尔常量 System.out.println(true); System.out.println(false); //空常量，不能直接用来打印输出 // System.out.println(null); 会报错 &#125;&#125; 数据类型java的数据类型分为两大类： 基本数据类型 引用数据类型 基本数据类型四类八种基本数据类型 数据类型 关键字 内存占用 取值范围 字节型 byte 1个字节 -128~127 短整型 short 2个字节 -32768~32767 整形 int（默认） 4个字节 -2^31^~2^31^-1 长整型 long 8个字节 -2^63^~2^63^-1 单精度浮点数 float 4个字节 1.4013E-45~3.4028E+38 双精度浮点数 double（默认） 8个字节 4.9E-324~1.7977E+308 字符型 char 2个字节 0-65535 布尔类型 boolean 1个字节 true false 【SP】 java中的默认类型，整形是int，浮点型是double 字符串不是基本类型而是引用类型 浮点型可能只是一个近似值，并非精确的值 数据范围与字节数并不一定相关，如float数据范围比long更加广泛，单float是4字节而long是8字节 如果使用float需加后缀F，若使用long后缀需加L，推荐使用大写字母后缀 1234System.out.println(100);//是int型System.out.println(100L);//是long型System.out.println(100.2);//是double型System.out.println(100F);//是float型 变量的定义变量定义有以下两种方式 创建一个变量并且使用的格式 数据类型 变量名称 //创建一个变量 变量名称 = 数据值 //赋值 一步到位 数据类型 变量名称 = 数据值；//在创建变量同时，立刻放入指定的数据值 12 public class Day02&#123;public static void main(String[] args)&#123; 1234567891011121314151617181920212223242526272829303132333435363738 //方式一 int num1; num1 =10; System.out.println(num1); //方式二 int num2 = 25; System.out.println(num2); System.out.println(&quot;--------------&quot;); byte num3 = 30; //注意右侧数值不能超过左侧数据类型的数据范围 System.out.println(num3); //byte num4 = 400;// 右侧超出了byte的取值范围，错误！！ short num5 = 50; System.out.println(num5); long num6 = 3000000L; System.out.println(num6); float num7 = 2.5F; System.out.println(num7); double num8 = 1.2; System.out.println(num8); char zifu1 = &apos;A&apos;; System.out.println(zifu1); zifu1 = &apos;中&apos;; System.out.println(zifu1); boolean var1 = true; System.out.println(var1); var1 = false; System.out.println(var1); &#125; &#125; 123456789101112131415161718**TIPS*** 变量之间不能重复* 对于float和long后缀不能丢掉* 如果用type和long注意取值范围* 没有进行赋值的变量，不能直接使用，一定要复制之后才能进行使用（如打印输出操作）* 变量不要超出变量的定义域# 数据类型转换1. 自动转换 一个int类型变量和一个byte类型变量进行加法运算，结果是什么类型？ ```java int i =1; byte b = 2; 运算结果，变量的类型将是int类型，这就是出现了数据类型的自动类型转换现象 自动转换(隐式)：将取值范围小的类型自动提升为取值范围大的类型 12345678public static void main(String[] args) &#123; int i =1; byte =2; //byte x = b+i //报错 //int 类型和byte；类型运算，结果是int int j = b+i; System.out.println(j);&#125; 规则：数据范围从小到大 123long num1 = 100;//左边是long，右边是int，从int--long是从小到大，自当发生数据类型转换double num2 = 2.5F;float num3 =30L; 强制类型转换 代码需要进行特殊的格式处理，不能自动完成 范围小的类型 范围小的变量名 = （范围小的类型）原本范围大的数据 1234int num = (int) 100L;//左边是int类型，右边是long类型，不一样//long --&gt; int ，不是从小到大，不能发生自动化类型转换//范围小的类型 范围小的变量名 = （范围小的类型）原本范围大的数据 Tips 强制类型转换一般不使用，因为有可能发生精度损失，数据溢出 12int num =(int) 6000000000L;输出num为17亿数据溢出 byte/short/char三种类型都可以发生数学运算 byte/short/char三种类型在运算的时候，都会被首先提升为int类型然后再计算 boolean 不能发生数据类型转换 运算符一元运算符 取反 ！ 自增 ++ 自减 – 二元运算符 + - * / = 三元运算符数据类型 变量名称 = 条件判断 ？ 表达式A：表达式B; 123int a;int b;int max = a &gt; b ? a : b; Tips 必须同时保证表达式A和表达式B都符合左侧数据类型的要求 三元运算符的结果必须被使用 123int result = 3 &gt; 4 ? 2.5 : 10 ; //错误 数据类型不一致System.out.println(a &gt; b ? a : b);//正确写法a &gt; b ? a : b //错误写法，没有进行使用","categories":[{"name":"java","slug":"java","permalink":"http://www.windknew.com/blog/categories/java/"}],"tags":[{"name":"学习","slug":"学习","permalink":"http://www.windknew.com/blog/tags/学习/"},{"name":"java","slug":"java","permalink":"http://www.windknew.com/blog/tags/java/"}]},{"title":"在家java学习第一天（java认识和环境搭建）","slug":"java","date":"2020-02-06T08:41:42.000Z","updated":"2020-02-13T02:03:41.173Z","comments":true,"path":"java/","link":"","permalink":"http://www.windknew.com/java/","excerpt":"","text":"前言​ 下学期要学习java，闲来无事，开始了自学之旅，用于记录学习java的全过程，当是学习笔记吧 什么是java，以及java发展史什么是java语言Java语言是美国Sun公司（Stanford University Network）斯坦福大学网络公司，在1995年推出的高级编程语言，所谓编程语言，是计算机的语言，人门可以使用编程语言对计算机下达命令，让计算机完成人门需要的功能 Java语言之父James Gosling就是这家公司非常nb的程序员，关于java之父的详细了解，可以看看以下这篇文章 ​ java之父及java诞生 ​ java语言之父 James Gosling Java发展史 1995年Sun公司发布java1.0版本 1997年发布java1.1版本 1998年发布java1.2版本 2000年发布java1.3版本 2002年发布java1.4版本 2004年发布java5版本（因为和1.4变化太大，更新力度太大，所以用大版版本号来表示） 2006年发布java6版本 2009年Oracle甲骨文公司收购Sun公司，并于2011年发布java7版本 2014年发布java8版本 2017年9月发布java9版本 2018年3月发布java10版本 Java的应用Java语言经过多年的发展已经形成了一个较为健全的语言生态，在Web开发、大数据开发、Android开发等领域均有广泛的应用，而且凭借稳定的性能表现和较强的扩展性，目前Java语言依然是大型互联网平台较为常见的解决方案，采用Java语言进行大型后端系统的开发会在很大程度上降低开发风险。JAVA的一次编译，到处运行，你知道多少？](https://blog.csdn.net/wangyongxia921/article/details/28117155) Java环境的搭建 JVM (java Virtual Machine):java虚拟机，简称JVM，是运行所有java程序的假想计算机，是java程序的运行环境，是java最具吸引力的特性之一，我们编写的JVM之上 跨平台：任何软件的运行，都必须要运行在操作系统之上，而我们用Java编写的软件可以运行在任何的操作系统上，这个特性称为java语言的跨平台特性，该特性是由JVM实现的，我们编写的程序运行在JVM上，而JVM运行在操作系统上（这就是著名的‘一次编写，到处运行’）可以看看这篇文章JAVA的一次编译，到处运行，你知道多少？ ​ JRE和JDK JRE (java Runtime Environment) :是java程序的运行时环境，包含JVM和运行时所需要的核心类库 JDK (java Development Kit):是java程序开发工具包，包含JRE和开发人员使用的工具 我们想要运行一个已有的java程序，那么只需要安装JRE即可 我们想要开发一个全新的java程序，那么必须安装JDK JDK，JRE，JVM关系图 下载安装JDK 可以选择不同的版本号,(我无论什么都喜欢下载最新的我下载的是最新的) 选择相应的java版本，点进去 选择相应系统的jdk点击下载 下载成功之后点击安装 注意这个路径问题 添加环境变量将我们的jdk安装的bin目录添加到环境变量path里 然后打开cmd测试 这样就说明，jdk环境变量配好了 Hello World新建一个文本文档，命名为HelloWorld.java 12345public class HelloWorld&#123; public static main(String[] args)&#123; System.out.println(\"Hello,World\"); &#125;&#125; 执行javac 编译HelloWorld.java执行后什么都不出现，同目录下会出现.class的字节码文件 然后java HelloWorld 就能成功执行该文件 注意用的是java HelloWorld，java后面一个空格，加不加后缀的文件名 今天就学了这么多，明天再学变量什么的，","categories":[{"name":"java","slug":"java","permalink":"http://www.windknew.com/blog/categories/java/"}],"tags":[{"name":"学习","slug":"学习","permalink":"http://www.windknew.com/blog/tags/学习/"},{"name":"java","slug":"java","permalink":"http://www.windknew.com/blog/tags/java/"}]},{"title":"文泉课堂爬虫源码","slug":"wenquanketang-spider","date":"2020-02-05T02:21:59.000Z","updated":"2020-02-10T08:14:32.766Z","comments":true,"path":"wenquanketang-spider/","link":"","permalink":"http://www.windknew.com/wenquanketang-spider/","excerpt":"","text":"前言今天打开发现文泉课堂需要登陆才能进行访问，一登陆，发现，昨天的502，明显好多了今天附上所有源码，供大家学习和参考 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160#!/usr/bin/env python# -*- coding:utf-8 -*-# Author:风晓import requestsimport timefrom pathlib import Pathimport osimport jwtimport jsonfrom tqdm import trangedata =&#123;&#125;headers =&#123; &apos;user-agent&apos;: &apos;Mozilla/5.0 (Windows NT 10.0; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/69.0.3497.100 Safari/537.36&apos;, &#125;JWT_SECRET = &apos;g0NnWdSE8qEjdMD8a1aq12qEYphwErKctvfd3IktWHWiOBpVsgkecur38aBRPn2w&apos;# SESS = httpx.Client()URL = &apos;https://lib-nuanxin.wqxuetang.com&apos;# SESS.get(URL)&apos;&apos;&apos; jwt key for bookid &apos;&apos;&apos;# url = &quot;https://lib-nuanxin.wqxuetang.com/v1/read/k?bid=%s&quot; % bookiddef gen_jwt_key(bookid,cooike): url = f&apos;&#123;URL&#125;/v1/read/k?bid=&#123;bookid&#125;&apos; print(url) # r = self.session.get(url, timeout=5) # r = SESS.get(url, timeout=5) # j = json.loads(r.text) head = &#123; &apos;Accept&apos;: &apos;text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,*/*;q=0.8&apos;, &apos;Accept-Encoding&apos;: &apos;gzip, deflate, sdch&apos;, &apos;Accept-Language&apos;: &apos;zh-CN,zh;q=0.8&apos;, &apos;Connection&apos;: &apos;keep-alive&apos;, &apos;Cookie&apos;: cooike, &apos;Host&apos;: &apos;lib-nuanxin.wqxuetang.com&apos;, &apos;Upgrade-Insecure-Requests&apos;: &apos;1&apos;, &apos;User-Agent&apos;: &apos;Mozilla/5.0 (Windows NT 10.0; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/49.0.2623.112 Safari/537.36&apos;, &#125; try: resp = requests.get(url,headers = head) resp.raise_for_status() except Exception as exc: print(exc) try: jdata = resp.json() except Exception as exc: jdata = &#123;&#125; res = jdata.get(&apos;data&apos;) if res is None: raise Exception(&apos;returned None, something is not right...&apos;) return resdef gen_jwt_token(bookid, page,cooike): &apos;&apos;&apos; gen jwt token &apos;&apos;&apos; cur_time = time.time() jwtkey = gen_jwt_key(bookid,cooike) print(jwtkey) jwttoken = jwt.encode( &#123; &quot;p&quot;: page, &quot;t&quot;: int(cur_time) * 1000, &quot;b&quot;: str(bookid), &quot;w&quot;: 1000, &quot;k&quot;: json.dumps(jwtkey), &quot;iat&quot;: int(cur_time), &#125;, JWT_SECRET, algorithm=&apos;HS256&apos;, ).decode(&apos;ascii&apos;) print(jwttoken) return jwttokendef bookinfo(bookid,cooike): &apos;&apos;&apos; bookinfo &apos;&apos;&apos; # url = f&quot;https://lib-nuanxin.wqxuetang.com/v1/read/initread?bid=&#123;self.bookid&#125;&quot; # noqa url = f&apos;&#123;URL&#125;/v1/read/initread?bid=&#123;bookid&#125;&apos; # r = self.session.get(url) head = &#123; &apos;Accept&apos;: &apos;text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,*/*;q=0.8&apos;, &apos;Accept-Encoding&apos;: &apos;gzip, deflate, sdch&apos;, &apos;Accept-Language&apos;: &apos;zh-CN,zh;q=0.8&apos;, &apos;Connection&apos;: &apos;keep-alive&apos;, &apos;Cookie&apos;: cooike, &apos;Host&apos;: &apos;lib-nuanxin.wqxuetang.com&apos;, &apos;Upgrade-Insecure-Requests&apos;: &apos;1&apos;, &apos;User-Agent&apos;: &apos;Mozilla/5.0 (Windows NT 10.0; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/49.0.2623.112 Safari/537.36&apos;, &#125; try: bookid = int(bookid) except Exception as exc: print(exc) raise if bookid &lt; 1: # logger.warning(f&apos; bookid &#123;bookid&#125; &lt; 1, setting bookid to 1&apos;) # bookid = 1 raise Exception(&apos; bookid must be bigger than zero&apos;) try: print(url) resp = requests.get(url,headers=head) resp.raise_for_status() except Exception as exc: print(exc) try: jdata = resp.json() except Exception as exc: print(exc) jdata = &#123;&#125; data = jdata.get(&apos;data&apos;) print(data) if data is None: raise Exception( &apos;returned None, something is not right...可能无此书号，也有可能是网络有问题或IP被限制……&apos; # noqa ) bookinfo.jdata = jdata # print(data.get(&apos;canreadpages&apos;)) print(data.get(&apos;name&apos;), data.get(&apos;canreadpages&apos;)) return data.get(&apos;name&apos;), data.get(&apos;canreadpages&apos;)def fetch_png(bookid, page=1): &apos;&apos;&apos; download booid page img &apos;&apos;&apos; token = gen_jwt_token(bookid, page,cooike) print(token) url = f&apos;&#123;URL&#125;/page/img/&#123;bookid&#125;/&#123;page&#125;?k=&#123;token&#125;&apos; print(url) headers = &#123; &apos;accept&apos;: &apos;image / webp, image / *, * / *;q = 0.8&apos;, &apos;referer&apos;: f&apos;&#123;URL&#125;/read/pdf/&#123;bookid&#125;&apos;, &apos;user-agent&apos;: &apos;Mozilla/5.0 (Windows NT 10.0; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/69.0.3497.100 Safari/537.36&apos;, # noqa &#125; req = requests.get(url,headers=headers) res = req.content if not os.path.exists(str(bookid)): os.mkdir(str(bookid)) with open(str(bookid)+&apos;/&apos;+str(page+1000)+&apos;.jpg&apos;,&apos;wb&apos;)as f: f.write(res) return resif __name__ == &apos;__main__&apos;: &apos;&apos;&apos;使用时更改bookid和将你的cooike更换成你的&apos;&apos;&apos; &apos;&apos;&apos;https://lib-nuanxin.wqxuetang.com/v1/read/k?bid=3187886&apos;&apos;&apos; &apos;&apos;&apos;cooike用上面的url然后进去f12调试复制里面的cooike&apos;&apos;&apos; bookid =3187886 cooike = &apos;_gid=377254409517; _gidv=6699d59c633414a0287f63aa61c56d4e; PHPSESSID=ngeq25ktm1cp2ipd54kabr2eii; Hm_lvt_a84b27ffd87daa3273555205ef60df89=1580866455,1580876574,1580883745,1580883761; Hm_lpvt_a84b27ffd87daa3273555205ef60df89=1580883767; acw_tc=3ccdc15315808917923211688e5e6c7e01cc28622fbf0190a83bc6ce183541&apos; try: page = bookinfo(bookid,cooike)[1] print(page) if not os.path.exists(str(bookid)): os.mkdir(str(bookid)) for i in range(1,int(page)): if not os.path.exists(str(bookid)+&apos;/&apos;+str(i+1000)+&apos;.jpg&apos;): try: print(i) gen_jwt_token(bookid,i,cooike) fetch_png(bookid,i) time.sleep(6) except Exception as e: print(e) except Exception as e: print(e) 若大量遇到下面这种情况：空列表，则说明你的cooike可能过期及时更换就好 跑完一遍后打开你的图片保存路径，然后排序按大小，然后翻到最下面若和以下一样说明这几张没成功，删了 重新来一遍就好，重新跑，不会覆盖之前的，只会抓取没有成功的： 最后推荐一个好用的小工具，图片合成pdf工具：pic2pdf 拥有这些，就可以成功的得到了自己的电子书。。今天就到这儿吧","categories":[{"name":"python","slug":"python","permalink":"http://www.windknew.com/blog/categories/python/"}],"tags":[{"name":"爬虫","slug":"爬虫","permalink":"http://www.windknew.com/blog/tags/爬虫/"},{"name":"python","slug":"python","permalink":"http://www.windknew.com/blog/tags/python/"}]},{"title":"文泉课堂知识库图书爬虫","slug":"spider-wenquanketang","date":"2020-02-04T05:38:17.000Z","updated":"2020-02-10T08:14:15.056Z","comments":true,"path":"spider-wenquanketang/","link":"","permalink":"http://www.windknew.com/spider-wenquanketang/","excerpt":"","text":"前言昨天导员老师发了个通知，说在疫情期间，清华大学的文泉课堂资源免费开放，那何不用爬虫技术，将所有的的电子书下载下来，于是就有了这篇文章 思路首先确定一下爬取的思路，浏览了一下发现并没有直接下载的链接，只能免费的阅读里面的书，打开阅读界面，书是以图片的形式呈现的，于是我们的爬虫思路是按顺序爬取所有的图片，最后合成一个pdf文件，这样我们就成功的获取到了这本书的pdf版 过程我们打开浏览器，随便打开一本书，然后打开调试，发现网页源码并不能直接获得，是通过动态加载的，所以只能考虑图片地址的规律 我们会发现，图片的url是页数，后面是一串字符串，这时经百度发现这是jwt 可以理解成是web验证身份的一种方式吧，我也是第一次接触，在网上看了很多相关的文章，在这里推荐几篇 利用JWT生成Token的原理及公钥和私钥加密和解密的原则 JSON Web Token - 在Web应用间安全地传递信息 10分钟了解JSON Web令牌（JWT） Jwt简介 简单地说JWT 的原理是，服务器认证以后，生成一个 JSON 对象，发回给用户，就像下面这样。 1eyJhbGciOiJIUzI1NiJ9.eyJpc3MiOiJuaW5naGFvLm5ldCIsImV4cCI6IjE0Mzg5NTU0NDUiLCJuYW1lIjoid2FuZ2hhbyIsImFkbWluIjp0cnVlfQ.SwyHTEx_RQppr97g4J5lKXtabJecpejuef8AqKYMAJc jwt由三部分构成分别如下 123Header（头部）Payload（负载）Signature（签名） 我百度了一下有个jwt的在线解密的网站，进去后随便复制一个图片的token如图： 里面的数据： alg属性表示签名的算法（algorithm），默认是 HMAC SHA256（写成HS256）；typ属性表示这个令牌（token）的类型（type），JWT 令牌统一写为JWT。 中间的dict是Payload，可以理解成我们要给服务器的数据，其中p代表页数，t是时间戳，b是书的id就是bid，k值我看了半天没看懂，后来在网页中我发现了个请求如下图： ​ 刚好和上面的k值里的u，i，t，b，n对上，所以我就肯定没错了，是 这个 了，然后所有的东西确定了之后，我们就开始构建吧,然后在Headers里找到相关信息，并进行获取就行 最下面的是Signature 部分是对前两部分的签名，防止数据篡改。 算出签名以后，把 Header、Payload、Signature 三个部分拼成一个字符串，每个部分之间用”点”（.）分隔，就可以返回给用户。 代码如下图示 123456789101112131415161718def gen_jwt_token(bookid, page): ''' get jwt token ''' cur_time = time.time() //时间戳 jwtkey = gen_jwt_key(bookid) //token里的k值 jwttoken = jwt.encode( &#123; \"p\": page, \"t\": int(cur_time) * 1000, \"b\": str(bookid), \"w\": 1000, # \"k\": json.dumps(self.jwtkey), \"k\": json.dumps(jwtkey), \"iat\": int(cur_time), &#125;, //进行编码 JWT_SECRET, algorithm='HS256', ).decode('ascii') return jwttoken k值获取代码 12345678910111213141516171819def gen_jwt_key(bookid): URL ='https://lib-nuanxin.wqxuetang.com' url = f'&#123;URL&#125;/v1/read/k?bid=&#123;bookid&#125;' try: resp = requests.get(url,headers = headers) resp.raise_for_status() except Exception as exc: print(exc) try: jdata = resp.json() except Exception as exc: jdata = &#123;&#125; res = jdata.get('data') if res is None: raise Exception('returned None, something is not right...') return res 有了这些我们就可以来轻松的获取图片了 我们可以发现图片的url规律是 12URL = 'https://lib-nuanxin.wqxuetang.com'f'&#123;URL&#125;/page/img/&#123;bookid&#125;/&#123;page&#125;?k=&#123;token&#125;' 然后就可以来获取图片了 1234567891011121314151617def fetch_png(bookid, page): ''' download book page img ''' token = gen_jwt_token(bookid, page) print(token) url = f'&#123;URL&#125;/page/img/&#123;bookid&#125;/&#123;page&#125;?k=&#123;token&#125;' print(url) headers = &#123; 'accept': 'image / webp, image / *, * / *;q = 0.8', 'referer': f'&#123;URL&#125;/read/pdf/&#123;bookid&#125;', 'user-agent': 'Mozilla/5.0 (Windows NT 10.0; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/69.0.3497.100 Safari/537.36', &#125; req = requests.get(url,headers=headers) res = req.content if not os.path.exists(str(bookid)): os.mkdir(str(bookid)) with open(str(bookid)+'/'+str(page)+'.jpg','wb')as f: f.write(res) 当我们获取到书的所有图片如图： 然后我们再用python将这些图片合成一个完整的pdf 具体代码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748# -*- coding:utf-8 -*-#!/usr/bin/env python# Author:windknewimport osfrom reportlab.lib.units import mm, inchfrom reportlab.lib.pagesizes import A4,A5, landscapefrom reportlab.pdfgen import canvas# 图片文件名称列表IMAGEFILES = []def convertpdf(pdfFile): '''多个图片合成一个pdf文件''' (w, h) = landscape(A5) # cv = canvas.Canvas(pdfFile,pagesize=landscape(A5)) for imagePath in IMAGEFILES: print(imagePath) cv.drawImage(imagePath, 0, 0, w, h) cv.showPage() cv.save()def getListImages(dirPath): '''读取指定文件夹下所有的JPEG图片，存入列表''' if dirPath is None or len(dirPath) == 0: raise ValueError('dirPath不能为空，该值为存放图片的具体路径文件夹！') if os.path.isfile(dirPath): raise ValueError('dirPath不能为具体文件，该值为存放图片的具体路径文件夹！') if os.path.isdir(dirPath): for imageName in os.listdir(dirPath): if imageName.endswith('.jpg') or imageName.endswith('.jpeg'): absPath =converPath(dirPath) + imageName IMAGEFILES.append(absPath)def converPath(dirPath): if dirPath is None or len(dirPath) == 0: raise ValueError('dirPath不能为空！') if os.path.isfile(dirPath): raise ValueError('dirPath不能为具体文件，该值为文件夹路径！') if not str(dirPath).endswith(\"\\\\\"): return dirPath + \"\\\\\" return dirPathif __name__ == '__main__': getListImages('C:/Users/lyh/Desktop/ershoushu/2175744/') pdfFile = converPath('C:/Users/lyh/Desktop/ershoushu/2175744/')+'2175744'+ \".pdf\" convertpdf(pdfFile) 结语总结 这样我们就成功的获取到了一本想要的pdf，但是文泉课堂不知什么原因有时候就会502，这样的话我们就需要多爬几次，直到把整本书的img都抓到，这次分享就到这儿了","categories":[{"name":"python","slug":"python","permalink":"http://www.windknew.com/blog/categories/python/"}],"tags":[{"name":"爬虫","slug":"爬虫","permalink":"http://www.windknew.com/blog/tags/爬虫/"},{"name":"python","slug":"python","permalink":"http://www.windknew.com/blog/tags/python/"}]},{"title":"使用hexo搭建博客（四）","slug":"hexo-3","date":"2020-02-04T04:18:25.000Z","updated":"2020-02-10T08:11:55.804Z","comments":true,"path":"hexo-3/","link":"","permalink":"http://www.windknew.com/hexo-3/","excerpt":"","text":"前言承接上篇博客，上篇博客中我们在Github上部署成功，但Github上的访问速度在国内较慢，而且免费提供的资源有限，不适于长时期的博客运作，所以在此篇文章中，来说一下，我部署在云服务器的过程以及遇到的问题 首先我们了解一下，hexo利用git更新的流程，部署在Github上和部署在云服务器上没有特别大的本质区别 整个流程就是本地将markdown文件渲染成静态文件，然后Git推送到服务器的r代码仓库，让服务器通过钩子（hook）同步网站根目录，再利用nginx托管这些静态资源，就可以实现访问 环境本地环境Windows10,在本地已经装好了Git，nodejs，hexo，并且在本地已经成功的能调试出来hexo 服务器环境华为的ECS（centos7） 已装好了git，nodejs，以及编译好了nginx（编译这玩意儿有些慢，我编译的时候大概花了将近30分钟） 本地机器配置配置密钥在终端使用git bash生成公匙，命令如下： 1ssh-keygen -t rsa 然后一路回车， 就会在如图示的文件路径下生成一个密钥文件id_rsa.pub 这个密钥文件我们后面会用到，这个密钥相当于我们访问服务器的钥匙 云服务器配置Git，nodejs，Nginx等安装具体安装过程可自行百度 创建git新用户以及进行配置创建git新用户1234adduser git #加入git用户passwd git #配置你的密码chmod 740 /etc/sudoers/ #修改git的sudo使用权限为只读vim /etc/sudoers #编辑sudoers 打开sudoers，找到以下内容 12## Allow root to run any commands anywhereroot ALL=(ALL) ALL 在他的下面加入以下内容 1git ALL=(ALL) ALL 然后wq保存，并且将权限修改回来 1chmod 400 /etc/sudoers 将公钥配置到服务器上就是刚才我们生成的那个文件将该文件内容复制，在云服务器端，切换至刚建好的git用户下，创建.ssh文件和和authorized_keys文件 123su gitmkdir ~/.sshvim ~/.ssh/authorized_keys 然后修改权限 123cd ~chmod 600 .ssh/authorzied_keys # 将文件设置为可读可写chmod 700 .ssh #将该文件夹设置为可读可写可执行（访问） 测试git链接切换到本地机器在本地机器上测试是否能连接到你的远程Git用户 1ssh -v git@SERVER_IP 测试成功会出现如下：如果测试不成功，看看具体的输出信息，通常是公钥没配置好的原因，不用担心，把原来生成的公钥删了，try again 就欧克了 创建网站根目录创建网站的根目录目的是为了让nginx进行托管hexo 生成的静态文件 创建一个目录用于作为网站的根目录，切换到root用 12su rootmkdir /home/hexo # 此目录为网站的根目录 然后变更该目录的所有者 1chown git:git -R /home/hexo 配置nginx安装过程自行度娘就好，编译好nginx后进入nginx的配置文件 1vim conf/nginx.conf 12345678910111213141516171819server&#123; listen 8081; #监听8081端口 server_name 139.159.245.212; #你的服务器名，通常是域名，如果是域名，你就需要监听80端口 root /home/hexo; #网站的根目录,根据自己所建自行修改 location / &#123; &#125; #access_log logs/access.log mylog; error_page 404 /404.html; #配置40x页面 location = /40x.html &#123; &#125; error_page 500 502 503 504 /50x.html; #配置50x页面 location = /50x.html &#123; &#125; &#125; 注意使用 nginx -t 命令检查配置文件的语法是否出错。然后使用 systemctl restart nginx.service 或者 在编译好的nginx目录下使用sbin/nginx -s reload命令重启服务即可 实现自动化部署建立git裸库（就是空的）在root用户下 123su rootcd /home/git # 在 git 用户目录下创建git init --bare blog.git 这时，git 用户的 ~ 目录下就存在一个 blog.git 文件夹，可使用 ls 命令查看。再修改blog.git 的所有者 使用钩子同步网站根目录在这使用的是 post-receive 这个钩子，当 git 有收发的时候就会调用这个钩子。 在 blog.git裸库的 hooks 文件夹中，新建 post-receive 文件。 1vim blog.git/hooks/post-receive 填入以下内容，其中 /home/hexo 为网站目录，根据自己的填入,保存退出。 12#!/bin/shgit --work-tree=/home/hexo --git-dir=/home/git/blog.git checkout -f 该钩子的意思是当本地有提交到服务器时，会将文件放在/home/hexo下 -f这个参数如果在多人协作的博客中可能会引发不好的结果，因为他是强制更新的意思，会将本地版本覆盖掉远程服务器的版本，但是是个人的博客系统就无所谓了 保存后，要赋予这个文件可执行权限。 1chmod +x /home/git/blog.git/hooks/post-receive 本地机器中部署至服务器在本地中，和部署到 github 服务一样，需要先 hexo g 命令生成静态文件，通过 hexo s 命令能够正常进行本地访问，并且确保已经安装了 hexo-deployer-git。 配置Hexohexo 根目录下的 _config.yml 文件，找到 deploy。 1234deploy: type: git repo: git@SERVER:/home/git/blog.git # 填写你的服务器地址 将SERVER替换掉 branch: master # 分支 之后按照正常的流程部署，也可以在hexo项目中添加脚本scripts,脚本内容如下图所示（在package.json文件中添加） 测试自动化部署然后用hexo d 即可推送到远端服务器 然后可以用自己服务器ip访问自己的博客网站了 本次分享就到这儿，有任何问题欢迎留言，我会在第一时间，进行回复！！","categories":[{"name":"教程","slug":"教程","permalink":"http://www.windknew.com/blog/categories/教程/"}],"tags":[{"name":"hexo","slug":"hexo","permalink":"http://www.windknew.com/blog/tags/hexo/"},{"name":"blog","slug":"blog","permalink":"http://www.windknew.com/blog/tags/blog/"}]},{"title":"使用hexo搭建博客（三）","slug":"hexo-2","date":"2020-02-03T05:40:59.000Z","updated":"2020-02-10T08:11:42.570Z","comments":true,"path":"hexo-2/","link":"","permalink":"http://www.windknew.com/hexo-2/","excerpt":"","text":"部署发行项目前言这篇文章是基于你已经注册了github账号和创建了对应的仓库，通过配置ssh来建立连接 创建Repository创建一个Repository，名称规则为 1username.github.name 然后编辑hexo的配置文件_config.yml,修改如图示地方。repo修改你的仓库地方 生成ssh123$ ssh-keygen -t rsa -C &quot;邮件地址@youremail.com&quot;Generating public/private rsa key pair.Enter file in which to save the key (/Users/your_user_directory/.ssh/id_rsa):&lt;回车&gt; 然后一路回车 .赋值id_rsa.pub文件内容，在github的settings中，点选SSH keys，添加一个key，将内容粘贴进去 测试是否添加成功1ssh -T git@github.com 部署到github上在hexo中分别进行生成，上传 12hexo ghexo d 部署成功后，可通过 http://pangyuanni.github.io 进行访问，其中将pangyuanni替换为你自己的username即可 此次分享到这儿 下篇博客分享如何部署到自己的与服务器上","categories":[{"name":"教程","slug":"教程","permalink":"http://www.windknew.com/blog/categories/教程/"}],"tags":[{"name":"hexo","slug":"hexo","permalink":"http://www.windknew.com/blog/tags/hexo/"},{"name":"blog","slug":"blog","permalink":"http://www.windknew.com/blog/tags/blog/"}]},{"title":"使用hexo搭建博客（二）","slug":"hexo-1","date":"2020-02-02T02:34:30.000Z","updated":"2020-02-10T08:11:26.806Z","comments":true,"path":"hexo-1/","link":"","permalink":"http://www.windknew.com/hexo-1/","excerpt":"","text":"前言 承接上篇博客，上篇博客中我们已经能够在本地成功运行我们的hexo博客，这篇文章我们来说说hexo的主题等个性化操作 主题 Hexo官网有很多很多主题供我们选择，我们可以在这些主题的基础之下进行修改，或者加入我们个性化的元素，hexo的官网网址是https://hexo.io/zh-cn/， 打开之后是这样，打开之后就是对hexo优点的介绍，然后我们选择主题然后打开就可以看到很多很多主题，由于hexo的服务器在国外加载可能较慢，耐心等待就好。 然后每个主题对应的名字就是主题的github地址，在我们hexo项目文件中找到theme进入之后，使用git clone 加主题的github地址，就可以把相应的主题文件克隆到我们的本地，我用我使用的material-x 这个主题为例，地址是https://github.com/xaoxuu/hexo-theme-material-x.git 1git clone https://github.com/xaoxuu/hexo-theme-material-x.git 这样就能将主题文件克隆到本地，如图示，当然也可以在浏览器里下载然后，解压到你的themes文件夹下 克隆完看看 看看使用说明，有没有相关的依赖包需要下载，若有按照说明进行下载，如 material-x npm i -S hexo-generator-search hexo-generator-json-content hexo-renderer-less Hexo网站配置文件123在根目录下的_config.yml主要是对网站的总属性进行设置如：网站标题，网站logo,网站插件使用等全局的属性主题目录下的_config.yml主要是针对网站的布局，导航等特性设置进行设 启用主题打开站点配置文件（根目录下的_config.yml）找到theme，将其值改为你下载的主题的名字，如下 PS :注意theme的冒号后面有个空格，不然会报错 然后再次启动我们的hexo，打开localshost:4000就可以看到主题效果 这样我们就更换了一个主题 关于网站的配置我们都可在网站的配置文件下更改： 刚更换完主题后，配置文件是这样的： 自己配置完是这样的 title是网站的标题 avatar 是网站的图标， logo是网站的logo， subtitle 是网站副标题 description 是网站描述 author 是作者 timezone 是时区 language 是语言 其他配置暂时可忽略 然后对于其他关于主题的设置可以到themes文件夹下里的主题文件里的_config.yml里面进行相关配置，比如评论系统，字数统计，背景图，等等相关配置都在里面进行配置，在配置文件里都有相关说明。 此次分享就到这儿，下篇博客我们分享如何部署项目","categories":[{"name":"教程","slug":"教程","permalink":"http://www.windknew.com/blog/categories/教程/"}],"tags":[{"name":"hexo","slug":"hexo","permalink":"http://www.windknew.com/blog/tags/hexo/"},{"name":"blog","slug":"blog","permalink":"http://www.windknew.com/blog/tags/blog/"}]},{"title":"使用hexo 搭建博客(一)","slug":"hexo","date":"2020-01-30T04:09:29.000Z","updated":"2020-02-10T08:09:45.001Z","comments":true,"path":"hexo/","link":"","permalink":"http://www.windknew.com/hexo/","excerpt":"","text":"使用Hexo搭建博客（一）引言： 本来刚开始想用python的django框架进行个人博客的搭建，但是使用python框架进行搭建的话， 但是进行到一半就不想干了，因为代码量太复杂，太繁琐，后来在网上发现了hexo这个专业的博客框架，搭建起来比较django省时省力，就决定用Hexo来搭建，在本地搭建没什么问题，但部署在云服务器的过程异常艰难。但最终，在神器——百度 的帮助下，问题全部解决 Hexo 说明Hexo是基于nodeJS环境的静态博客，简单来说就是轻量，简易，高逼格的博客工具，hexo是将markdown文件生成静态的html然后将生成的html上传到我们的服务器，简而言之：hexo是个静态页面生成，上传的工具 准备环境先安利一个在windows下非常好用的命令行工具cmder,关于他的好用之处，在另一篇博客有详细说明 Node.js 下载后，双击打开安装，也是一路next，不过在Custom Setup这一步记得选 Add to PATH ,这样你就不用自己去配置电脑上环境变量了 Git 下载安装，下载后一路next就好 用npm安装Hexo 1npm install -g hexo-cli // npm是安装Nodejs一起安装的包管理工具 这样我们的hexo在本地就差不多完成了，然后我们新建一个空的文件夹，进去初始化博客（这里我新建一个blog的文件夹）然后输入下列命令 12hexo init # hexo会在目标文件夹简历网站所需要的所有文件npm install # 安装依赖包 也可以使用 hexo init ，其中 为保存Hexo的项目路径，然后就等待clone，就会把各种配置文件下载到你的文件夹中了， 本地启动12hexo g #等同于hexo generate,胜场静态文件到public文件夹hexo s # 等同于hexo server,在本地服务器运行 还有一个命令 1hexo clean #作为清除静态文件夹的内容并删掉，主要用于更改变更了某些地方导致页面显示不完善 之后就可以打开浏览器并输入ip地址http://localhost:4000/查看，效果如下 新建页面和文章12hexo new 'title' #生成新文章，路径在:\\source\\_post\\title.mdhexo new page 'title' #生成新页面,可在主题配置文件中配置页面 生成文章或页面的模板放在博客文件夹根目录下的 scaffolds/ 文件夹里面，文章对应的是 post.md ，页面对应的是page.md，草稿的是draft.md 编辑文章123456789---title: Start My Blog Trip — Power By Hexo # 文章页面上的显示名称，可以任意修改，不会出现在URL中date: 2017-2-10 23:49:28 # 文章生成时间，一般不改categories: diary # 文章分类目录，多个分类使用[a,b,c]这种格式tags: [Hexo,diary] # 文章标签---#这里开始使用markdown格式输入你的正文。&lt;!--more--&gt; #more标签以下的内容要点击“阅读全文”才能看见，#more标签以上的内容为你首页显示文章的摘要部分 Markdown文章编辑如果不熟悉MD语法，可以去百度，B站找教学，不难，常用的语法就那么几个 再给大家安利个md文章神器Typora,还有hexo文章神器HexoEditor 常用命令总结1234567hexo init [folder] # 初始化一个网站。如果没有设置 folder ，Hexo 默认在目前的文件夹建立网站hexo new [layout] &lt;title&gt; # 新建一篇文章。如果没有设置 layout 的话，默认使用 _config.yml 中的 default_layout 参数代替。如果标题包含空格的话，请使用引号括起来hexo version # 查看版本hexo clean # 清除缓存文件 (db.json) 和已生成的静态文件 (public)hexo g # 等于hexo generate # 生成静态文件hexo s # 等于hexo server # 本地预览hexo d # 等于hexo deploy # 部署，可与hexo g合并为 hexo d -g 本篇文章先到这儿，下篇文章给大家分享分享打造个性化的hexo-blog","categories":[{"name":"教程","slug":"教程","permalink":"http://www.windknew.com/blog/categories/教程/"}],"tags":[{"name":"hexo","slug":"hexo","permalink":"http://www.windknew.com/blog/tags/hexo/"},{"name":"blog","slug":"blog","permalink":"http://www.windknew.com/blog/tags/blog/"}]}]}